---
title: FIS 源码 - 增量编译与依赖扫描细节
date: 2015-05-11
author: TAT.casperchen
source_link: http://www.alloyteam.com/2015/05/fis%e6%ba%90%e7%a0%81-%e5%a2%9e%e9%87%8f%e7%bc%96%e8%af%91%e4%b8%8e%e4%be%9d%e8%b5%96%e6%89%ab%e6%8f%8f%e7%bb%86%e8%8a%82/
---

<!-- {% raw %} - for jekyll -->

前面已经提到了 `fis release` 命令大致的运行流程。本文会进一步讲解增量编译以及依赖扫描的一些细节。

首先，在 `fis release` 后加上`--watch` 参数，看下会有什么样的变化。打开命令行

    fis release --watch
     

不难猜想，内部同样是调用 `release()`方法把源文件编译一遍。区别在于，进程会监听项目路径下源文件的变化，一旦出现文件（夹）的增、删、改，则重新调用 `release()`进行增量编译。

并且，如果资源之间存在依赖关系（比如资源内嵌），那么一些情况下，被依赖资源的变化，会反过来导致资源引用方的重新编译。

```html
&lt;span class="comment">// 是否自动重新编译&lt;/span>
&lt;span class="keyword">if&lt;/span>(options.watch){
    watch(options); &lt;span class="comment">// 对！就是这里&lt;/span>
} &lt;span class="keyword">else&lt;/span> {
    release(options);
}
 
```

下面扒扒源码来验证下我们的猜想。

## watch (opt) 细节

源码不算长，逻辑也比较清晰，这里就不上伪代码了，直接贴源码出来，附上一些注释，应该不难理解，无非就是重复**文件变化–>release (opt)**这个过程。

在下一小结稍稍展开下增量编译的细节。

```html
&lt;span class="keyword">function&lt;/span> watch(opt){
    &lt;span class="keyword">var&lt;/span> root = fis.project.getProjectPath();
    &lt;span class="keyword">var&lt;/span> timer = -&lt;span class="number">1&lt;/span>;
    &lt;span class="keyword">var&lt;/span> safePathReg = /[\/][_-.sw]+$/i;    &lt;span class="comment">// 是否安全路径（参考）&lt;/span>
    &lt;span class="keyword">var&lt;/span> ignoredReg = /[/](?:outputb[^/]*([/]|$)|.|fis-conf.js$)/i;  &lt;span class="comment">// ouput路径下的，或者 fis-conf.js 排除，不参与监听&lt;/span>
    opt.srcCache = fis.project.getSource(); &lt;span class="comment">// 缓存映射表，代表参与编译的源文件；格式为 源文件路径＝>源文件对应的File实例。比较奇怪的是，opt.srcCache 没见到有地方用到，在 fis.release 里，fis.project.getSource() 会重新调用，这里感觉有点多余&lt;/span>
 
    &lt;span class="comment">// 根据传入的事件类型（type），返回对应的回调方法&lt;/span>
    &lt;span class="comment">// type 的取值有add、change、unlink、unlinkDir&lt;/span>
    &lt;span class="keyword">function&lt;/span> listener(type){
        &lt;span class="keyword">return&lt;/span> &lt;span class="keyword">function&lt;/span> (path) {
            &lt;span class="keyword">if&lt;/span>(safePathReg.test(path)){
                &lt;span class="keyword">var&lt;/span> file = fis.file.wrap(path);
                &lt;span class="keyword">if&lt;/span> (type == &lt;span class="string">'add'&lt;/span> || type == &lt;span class="string">'change'&lt;/span>) {    &lt;span class="comment">// 新增 或 修改文件&lt;/span>
                    &lt;span class="keyword">if&lt;/span> (!opt.srcCache[file.subpath]) {  &lt;span class="comment">// 新增的文件，还不在 opt.srcCache 里&lt;/span>
                        &lt;span class="keyword">var&lt;/span> file = fis.file(path);
                        opt.srcCache[file.subpath] = file;  &lt;span class="comment">// 从这里可以知道 opt.srcCache 的数据结构了，不展开&lt;/span>
                    }
                } &lt;span class="keyword">else&lt;/span> &lt;span class="keyword">if&lt;/span> (type == &lt;span class="string">'unlink'&lt;/span>) {  &lt;span class="comment">// 删除文件&lt;/span>
                    &lt;span class="keyword">if&lt;/span> (opt.srcCache[file.subpath]) {
                        delete opt.srcCache[file.subpath];  &lt;span class="comment">// &lt;/span>
                    }
                } &lt;span class="keyword">else&lt;/span> &lt;span class="keyword">if&lt;/span> (type == &lt;span class="string">'unlinkDir'&lt;/span>) {   &lt;span class="comment">// 删除目录&lt;/span>
                     fis.util.map(opt.srcCache, &lt;span class="keyword">function&lt;/span> (subpath, file) {
                        &lt;span class="keyword">if&lt;/span> (file.realpath.indexOf(path) !== -&lt;span class="number">1&lt;/span>) {
                            delete opt.srcCache[subpath];
                        }
                    });                       
                }
                clearTimeout(timer);
                timer = setTimeout(&lt;span class="keyword">function&lt;/span>(){
                    release(opt);   &lt;span class="comment">// 编译，增量编译的细节在内部实现了&lt;/span>
                }, &lt;span class="number">500&lt;/span>);
            }
        };
    }
 
    &lt;span class="comment">//添加usePolling配置&lt;/span>
    &lt;span class="comment">// 这个配置项可以先忽略&lt;/span>
    &lt;span class="keyword">var&lt;/span> usePolling = &lt;span class="keyword">null&lt;/span>;
 
    &lt;span class="keyword">if&lt;/span> (typeof fis.config.get(&lt;span class="string">'project.watch.usePolling'&lt;/span>) !== &lt;span class="string">'undefined'&lt;/span>){
        usePolling = fis.config.get(&lt;span class="string">'project.watch.usePolling'&lt;/span>);
    }
 
    &lt;span class="comment">// chokidar模块，主要负责文件变化的监听&lt;/span>
    &lt;span class="comment">// 除了error之外的所有事件，包括add、change、unlink、unlinkDir，都调用 listenter(eventType) 来处理&lt;/span>
    &lt;span class="keyword">require&lt;/span>(&lt;span class="string">'chokidar'&lt;/span>)
        .watch(root, {
            &lt;span class="comment">// 当文件发生变化时候，会调用这个方法（参数是变化文件的路径）&lt;/span>
            &lt;span class="comment">// 如果返回true，则不触发文件变化相关的事件&lt;/span>
            ignored : &lt;span class="keyword">function&lt;/span>(path){
                &lt;span class="keyword">var&lt;/span> ignored = ignoredReg.test(path);    &lt;span class="comment">// 如果满足，则忽略&lt;/span>
                &lt;span class="comment">// 从编译队列中排除&lt;/span>
                &lt;span class="keyword">if&lt;/span> (fis.config.get(&lt;span class="string">'project.exclude'&lt;/span>)){
                    ignored = ignored ||
                        fis.util.filter(path, fis.config.get(&lt;span class="string">'project.exclude'&lt;/span>));   &lt;span class="comment">// 此时 ignoredReg.test(path) 为false，如果在exclude里，ignored也为true&lt;/span>
                }
                &lt;span class="comment">// 从watch中排除&lt;/span>
                &lt;span class="keyword">if&lt;/span> (fis.config.get(&lt;span class="string">'project.watch.exclude'&lt;/span>)){
                    ignored = ignored ||
                        fis.util.filter(path, fis.config.get(&lt;span class="string">'project.watch.exclude'&lt;/span>)); &lt;span class="comment">// 跟上面类似&lt;/span>
                }
                &lt;span class="keyword">return&lt;/span> ignored;
            },
            usePolling: usePolling,
            persistent: &lt;span class="keyword">true&lt;/span>
        })
        .on(&lt;span class="string">'add'&lt;/span>, listener(&lt;span class="string">'add'&lt;/span>))
        .on(&lt;span class="string">'change'&lt;/span>, listener(&lt;span class="string">'change'&lt;/span>))
        .on(&lt;span class="string">'unlink'&lt;/span>, listener(&lt;span class="string">'unlink'&lt;/span>))
        .on(&lt;span class="string">'unlinkDir'&lt;/span>, listener(&lt;span class="string">'unlinkDir'&lt;/span>))
        .on(&lt;span class="string">'error'&lt;/span>, &lt;span class="keyword">function&lt;/span>(err){
            &lt;span class="comment">//fis.log.error(err);&lt;/span>
        });
}
 
```

## 增量编译细节

增量编译的要点很简单，就是只发生变化的文件进行编译部署。在 `fis.release(opt, callback)`里，有这段代码：

```html
&lt;span class="comment">// ret.src 为项目下的源文件&lt;/span>
fis.util.map(ret.src, &lt;span class="keyword">function&lt;/span>(subpath, file){
    &lt;span class="keyword">if&lt;/span>(opt.beforeEach) {
        opt.beforeEach(file, ret);
    }
    file = fis.compile(file);
    &lt;span class="keyword">if&lt;/span>(opt.afterEach) {
        opt.afterEach(file, ret);   &lt;span class="comment">// 这里这里！&lt;/span>
    }
 
```

`opt.afterEach(file, ret)`这个回调方法可以在 `fis-command-release/release.js` 中找到。归纳下：

1.  对比了下当前文件的最近修改时间，看下跟上次缓存的修改时间是否一致。如果不一致，重新编译，并将编译后的实例添加到 `collection` 中去。
2.  执行 `deploy` 进行增量部署。（带着 collection 参数）

```html
opt.afterEach = &lt;span class="keyword">function&lt;/span>(file){
    &lt;span class="comment">//cal compile time&lt;/span>
    &lt;span class="comment">// 略过无关代码&lt;/span>
    
    &lt;span class="keyword">var&lt;/span> mtime = file.getMtime().getTime();  &lt;span class="comment">// 源文件的最近修改时间&lt;/span>
    &lt;span class="comment">//collect file to deploy&lt;/span>
    &lt;span class="comment">// 如果符合这几个条件：1、文件需要部署 2、最近修改时间 不等于 上一次缓存的修改时间&lt;/span>
    &lt;span class="comment">// 那么重新编译部署&lt;/span>
    &lt;span class="keyword">if&lt;/span>(file.release && lastModified[file.subpath] !== mtime){
        &lt;span class="comment">// 略过无关代码&lt;/span>
        
        lastModified[file.subpath] = mtime;
        collection[file.subpath] = file;  &lt;span class="comment">// 这里这里！！在 deploy 方法里会用到&lt;/span>
    }
};
 
```

关于 `deploy` ，细节先略过，可以看到带上了 `collection` 参数。

```html
deploy(opt, collection, total);
&lt;span class="comment">// 部署～&lt;/span>;
```

## 依赖扫描概述

在增量编译的时候，有个细节点很关键，变化的文件，可能被其他资源所引用（如内嵌），那么这时，除了编译文件之身，还需要对引用它的文件也进行编译。

原先我的想法是：

1.  扫描所有资源，并建立依赖分析表。比如某个文件，被多少文件引用了。
2.  某个文件发生变化，扫描依赖分析表，对引用这个文件的文件进行重新编译。

看了下 FIS 的实现，虽然大体思路是一致的，不过是反向操作。从资源引用方作为起始点，递归式地对引用的资源进行编译，并添加到资源依赖表里。

1.  扫描文件，看是否有资源依赖。如有，对依赖的资源进行编译，并添加到依赖表里。（递归）
2.  编译文件。

### 从例子出发

假设项目结构如下，仅有 `index.html`、`index.cc` 两个文件，且 `index.html` 通过 `__inline` 标记嵌入 `index.css`。

    ^CadeMacBook-Pro-3:fi a$ tree
    .
    ├── index.css
    └── index.html
     

`index.html` 内容如下。

```html
&lt;!DOCTYPE html>
&lt;html>
&lt;head>
    &lt;title>&lt;/title>
    &lt;link rel="stylesheet" type="text/css" href="index.css?__inline">
&lt;/head>
&lt;body>
 
&lt;/body>
&lt;/html>
 
```

假设文件内容发生了变化，理论上应该是这样

1.  index.html 变化：重新编译 index.html
2.  index.css 变化：重新编译 index.css，重新编译 index.html

理论是直观的，那么看下内部是怎么实现这个逻辑的。先归纳如下，再看源码

1.  对需要编译的每个源文件，都创建一个 Cache 实例，假设是 cache。cache 里存放了一些信息，比如文件的内容，文件的依赖列表 (deps 字段，一个哈希表，存放依赖文件路径到最近修改时间的映射)。
2.  对需要编译的每个源文件，扫描它的依赖，包括通过`__inline` 内嵌的资源，并通过 `cache.addDeps(file)`添加到 `deps` 里。
3.  文件发生变化，检查文件本身内容，以及依赖内容 (deps) 是否发生变化。如变化，则重新编译。在这个例子里，扫描 `index.html`，发现 `index.html` 本身没有变化，但 `deps` 发生了变化，那么，重新编译部署 `index.html`。

好，看源码。在 `compile.js` 里面，`cache.revert(revertObj)`这个方法检测文件本身、文件依赖的资源是否变化。

```html
    &lt;span class="keyword">if&lt;/span>(file.isFile()){
        &lt;span class="keyword">if&lt;/span>(file.useCompile && file.ext && file.ext !== &lt;span class="string">'.'&lt;/span>){
            &lt;span class="keyword">var&lt;/span> cache = file.cache = fis.cache(file.realpath, CACHE_DIR),   &lt;span class="comment">// 为文件建立缓存（路径）&lt;/span>
                revertObj = {};
                
            &lt;span class="comment">// 目测是检测缓存过期了没，如果只是跑 fis release ，直接进else&lt;/span>
            &lt;span class="keyword">if&lt;/span>(file.useCache && cache.revert(revertObj)){   &lt;span class="comment">// 检查依赖的资源（deps）是否发生变化，就在 cache.revert(revertObj)这个方法里&lt;/span>
                exports.settings.beforeCacheRevert(file);
                file.requires = revertObj.info.requires;
                file.extras = revertObj.info.extras;
                &lt;span class="keyword">if&lt;/span>(file.isText()){
                    revertObj.content = revertObj.content.toString(&lt;span class="string">'utf8'&lt;/span>);
                }
                file.setContent(revertObj.content);
                exports.settings.afterCacheRevert(file);
            } &lt;span class="keyword">else&lt;/span> {
 
```

看看 `cache.revert` 是如何定义的。大致归纳如下，源码不难看懂。至于 `infos.deps` 这货怎么来的，下面会立刻讲到。

1.  方法的返回值：缓存没过期，返回 true；缓存过期，返回 false
2.  缓存检查步骤：首先，检查文件本身是否发生变化，如果没有，再检查文件依赖的资源是否发生变化；

```html
    &lt;span class="comment">// 如果过期，返回false；没有过期，返回true&lt;/span>
    &lt;span class="comment">// 注意，穿进来的file对象会被修改，往上挂属性&lt;/span>
    revert : &lt;span class="keyword">function&lt;/span>(file){
        fis.log.debug(&lt;span class="string">'revert cache'&lt;/span>);
        &lt;span class="comment">// this.cacheInfo、this.cacheFile 中存储了文件缓存相关的信息&lt;/span>
        &lt;span class="comment">// 如果还不存在，说明缓存还没建立哪（或者被人工删除了也有可能，这种变态情况不多）&lt;/span>
        &lt;span class="keyword">if&lt;/span>(
            exports.enable
            && fis.util.exists(&lt;span class="keyword">this&lt;/span>.cacheInfo)
            && fis.util.exists(&lt;span class="keyword">this&lt;/span>.cacheFile)
        ){
            fis.log.debug(&lt;span class="string">'cache file exists'&lt;/span>);
            &lt;span class="keyword">var&lt;/span> infos = fis.util.readJSON(&lt;span class="keyword">this&lt;/span>.cacheInfo);
            fis.log.debug(&lt;span class="string">'cache info read'&lt;/span>);
            &lt;span class="comment">// 首先，检测文件本身是否发生变化&lt;/span>
            &lt;span class="keyword">if&lt;/span>(infos.version == &lt;span class="keyword">this&lt;/span>.version && infos.timestamp == &lt;span class="keyword">this&lt;/span>.timestamp){
                &lt;span class="comment">// 接着，检测文件依赖的资源是否发生变化&lt;/span>
                &lt;span class="comment">// infos.deps 这货怎么来的，可以看下compile.js 里的实现&lt;/span>
                &lt;span class="keyword">var&lt;/span> deps = infos[&lt;span class="string">'deps'&lt;/span>];
                &lt;span class="keyword">for&lt;/span>(&lt;span class="keyword">var&lt;/span> f in deps){
                    &lt;span class="keyword">if&lt;/span>(deps.hasOwnProperty(f)){
                        &lt;span class="keyword">var&lt;/span> d = fis.util.mtime(f);
                        &lt;span class="keyword">if&lt;/span>(d == &lt;span class="number">0&lt;/span> || deps[f] != d.getTime()){   &lt;span class="comment">// 过期啦！！&lt;/span>
                            fis.log.debug(&lt;span class="string">'cache is expired'&lt;/span>);
                            &lt;span class="keyword">return&lt;/span> &lt;span class="keyword">false&lt;/span>;
                        }
                    }
                }
                &lt;span class="keyword">this&lt;/span>.deps = deps;
                fis.log.debug(&lt;span class="string">'cache is valid'&lt;/span>);
                &lt;span class="keyword">if&lt;/span>(file){
                    file.info = infos.info;
                    file.content = fis.util.fs.readFileSync(&lt;span class="keyword">this&lt;/span>.cacheFile);
                }
                fis.log.debug(&lt;span class="string">'revert cache finished'&lt;/span>);
                &lt;span class="keyword">return&lt;/span> &lt;span class="keyword">true&lt;/span>;
            }
        }
        fis.log.debug(&lt;span class="string">'cache is expired'&lt;/span>);
        &lt;span class="keyword">return&lt;/span> &lt;span class="keyword">false&lt;/span>;
    },
 
```

## 依赖扫描细节

之前多次提到 `deps` 这货，这里就简单讲下依赖扫描的过程。还是之前 `compile.js` 里那段代码。归纳如下：

1.  文件缓存不存在，或者文件缓存已过期，进入第二个处理分支
2.  在第二个处理分支里，会调用 `process(file)`这个方法对文件进行处理。里面进行了一系列操作，如文件的 “标准化” 处理等。在这个过程中，扫描出文件的依赖，并写到 `deps` 里去。

下面会以 “标准化” 为例，进一步讲解依赖扫描的过程。

```html
&lt;span class="keyword">if&lt;/span>(file.useCompile && file.ext && file.ext !== &lt;span class="string">'.'&lt;/span>){
            &lt;span class="keyword">var&lt;/span> cache = file.cache = fis.cache(file.realpath, CACHE_DIR),   &lt;span class="comment">// 为文件建立缓存（路径）&lt;/span>
                revertObj = {};
                
            &lt;span class="comment">// 目测是检测缓存过期了没，如果只是跑 fis release ，直接进else&lt;/span>
            &lt;span class="keyword">if&lt;/span>(file.useCache && cache.revert(revertObj)){
                exports.settings.beforeCacheRevert(file);
                file.requires = revertObj.info.requires;
                file.extras = revertObj.info.extras;
                &lt;span class="keyword">if&lt;/span>(file.isText()){
                    revertObj.content = revertObj.content.toString(&lt;span class="string">'utf8'&lt;/span>);
                }
                file.setContent(revertObj.content);
                exports.settings.afterCacheRevert(file);
            } &lt;span class="keyword">else&lt;/span> {
                &lt;span class="comment">// 缓存过期啦！！缓存还不存在啊！都到这里面来！！&lt;/span>
                exports.settings.beforeCompile(file);
                file.setContent(fis.util.read(file.realpath));                
                process(file);  &lt;span class="comment">// 这里面会对文件进行"标准化"等处理&lt;/span>
                exports.settings.afterCompile(file);
                revertObj = {
                    requires : file.requires,
                    extras : file.extras
                };
                cache.save(file.getContent(), revertObj);
            }
        }
 
```

在 `process` 里，对文件进行了标准化操作。什么是标准化，可以参考[官方文档](http://fis.baidu.com/docs/more/fis-standard.html)。就是下面这小段代码

```html
        &lt;span class="keyword">if&lt;/span>(file.useStandard !== &lt;span class="keyword">false&lt;/span>){
            standard(file);
        }
 
```

看下 `standard` 内部是如何实现的。可以看到，针对类 HTML、类 JS、类 CSS，分别进行了不同的能力扩展（包括内嵌）。比如上面的 `index.html`，就会进入 `extHtml(content)`。这个方法会扫描 html 文件的`__inline` 标记，然后替换成特定的占位符，并将内嵌的资源加入依赖列表。

比如，文件的`&lt;link href="index.css?__inline" />` 会被替换成 `&lt;style type="text/css">&lt;&lt;&lt;embed:"index.css?__inline">>>`。

```html
&lt;span class="keyword">function&lt;/span> standard(file){
    &lt;span class="keyword">var&lt;/span> path = file.realpath,
        content = file.getContent();
    &lt;span class="keyword">if&lt;/span>(typeof content === &lt;span class="string">'string'&lt;/span>){
        fis.log.debug(&lt;span class="string">'standard start'&lt;/span>);
        &lt;span class="comment">//expand language ability&lt;/span>
        &lt;span class="keyword">if&lt;/span>(file.isHtmlLike){
            content = extHtml(content);  &lt;span class="comment">// 如果有 &lt;link href="index1.css?__inline" /> 会被替换成 &lt;style type="text/css">&lt;&lt;&lt;embed:"index1.css?__inline">>> 这样的占位符&lt;/span>
        } &lt;span class="keyword">else&lt;/span> &lt;span class="keyword">if&lt;/span>(file.isJsLike){
            content = extJs(content);
        } &lt;span class="keyword">else&lt;/span> &lt;span class="keyword">if&lt;/span>(file.isCssLike){
            content = extCss(content);
        }
        content = content.replace(map.reg, &lt;span class="keyword">function&lt;/span>(all, type, value){
 
            &lt;span class="comment">// 虽然这里很重要，还是先省略代码很多很多行&lt;/span>
 
    }
}
 
```

然后，在 `content.replace` 里面，将进入 `embed` 这个分支。从源码可以大致看出逻辑如下，更多细节就先不展开了。

1.  首先对内嵌的资源进行合法性检查，如果通过，进行下一步
2.  编译内嵌的资源。（一个递归的过程）
3.  将内嵌的资源加到依赖列表里。

```html
content = content.replace(map.reg, &lt;span class="keyword">function&lt;/span>(all, type, value){
            &lt;span class="keyword">var&lt;/span> ret = &lt;span class="string">''&lt;/span>, info;
            &lt;span class="keyword">try&lt;/span> {
                &lt;span class="keyword">switch&lt;/span>(type){
                    &lt;span class="keyword">case&lt;/span> &lt;span class="string">'require'&lt;/span>:
                        &lt;span class="comment">// 省略...&lt;/span>
                    &lt;span class="keyword">case&lt;/span> &lt;span class="string">'uri'&lt;/span>:
                        &lt;span class="comment">// 省略...&lt;/span>
                    &lt;span class="keyword">case&lt;/span> &lt;span class="string">'dep'&lt;/span>:
                        &lt;span class="comment">// 省略&lt;/span>
                    &lt;span class="keyword">case&lt;/span> &lt;span class="string">'embed'&lt;/span>:
                    &lt;span class="keyword">case&lt;/span> &lt;span class="string">'jsEmbed'&lt;/span>:
                        info = fis.uri(value, file.dirname);  &lt;span class="comment">// value ==> ""index.css?__inline""&lt;/span>
                        &lt;span class="keyword">var&lt;/span> f;
                        &lt;span class="keyword">if&lt;/span>(info.file){
                            f = info.file;
                        } &lt;span class="keyword">else&lt;/span> &lt;span class="keyword">if&lt;/span>(fis.util.isAbsolute(info.rest)){
                            f = fis.file(info.rest);
                        }
                        &lt;span class="keyword">if&lt;/span>(f && f.isFile()){
                            &lt;span class="keyword">if&lt;/span>(embeddedCheck(file, f)){ &lt;span class="comment">// 一切合法性检查，比如有没有循环引用之类的&lt;/span>
                                exports(f); &lt;span class="comment">// 编译依赖的资源&lt;/span>
                                addDeps(file, f);   &lt;span class="comment">// 添加到依赖列表&lt;/span>
                                f.requires.&lt;span class="keyword">forEach&lt;/span>(&lt;span class="keyword">function&lt;/span>(id){    
                                    file.addRequire(id);
                                });
                                &lt;span class="keyword">if&lt;/span>(f.isText()){
                                    ret = f.getContent();
                                    &lt;span class="keyword">if&lt;/span>(type === &lt;span class="string">'jsEmbed'&lt;/span> && !f.isJsLike && !f.isJsonLike){
                                        ret = JSON.stringify(ret);
                                    }
                                } &lt;span class="keyword">else&lt;/span> {
                                    ret = info.quote + f.getBase64() + info.quote;
                                }
                            }
                        } &lt;span class="keyword">else&lt;/span> {
                            fis.log.error(&lt;span class="string">'unable to embed non-existent file ['&lt;/span> + value + &lt;span class="string">']'&lt;/span>);
                        }
                        &lt;span class="keyword">break&lt;/span>;
                    &lt;span class="keyword">default&lt;/span> :
                        fis.log.error(&lt;span class="string">'unsupported fis language tag ['&lt;/span> + type + &lt;span class="string">']'&lt;/span>);
                }
            } &lt;span class="keyword">catch&lt;/span> (e) {
                embeddedMap = {};
                e.message = e.message + &lt;span class="string">' in ['&lt;/span> + file.subpath + &lt;span class="string">']'&lt;/span>;
                &lt;span class="keyword">throw&lt;/span>  e;
            }
            &lt;span class="keyword">return&lt;/span> ret;
        });
 
```

## 写在后面

更多内容，敬请期待。

文章: casperchen


<!-- {% endraw %} - for jekyll -->