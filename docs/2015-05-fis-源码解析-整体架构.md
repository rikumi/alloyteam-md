---
title: FIS 源码解析 - 整体架构
date: 2015-05-08
author: TAT.casperchen
source_link: http://www.alloyteam.com/2015/05/fis%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90-%e6%95%b4%e4%bd%93%e6%9e%b6%e6%9e%84/
---

<!-- {% raw %} - for jekyll -->

## 序言

这里假设本文读者对 [FIS](http://fis.baidu.com/) 已经比较熟悉，如还不了解，可猛击[官方文档](http://fis.baidu.com/)。

虽然 FIS 整体的源码结构比较清晰，不过讲解起来也是个系统庞大的工程，笔者尽量的挑重点的讲。如果读者有感兴趣的部分笔者没有提到的，或者是存在疑惑的，可以在评论里跑出来，笔者会试着去覆盖这些点。

下笔匆忙，如有错漏请指出。

## Getting started

如在开始剖析 FIS 的源码前，有三点内容首先强调下，这也是解构 FIS 内部设计的基础。

1、 FIS 支持三个命令，分别是 `fis release`、`fis server`、`fis install`。当用户输入 `fis xx` 的时候，内部调用 `fis-command-release`、`fis-command-server`、`fis-command-install` 这三个插件来完成任务。同时，FIS 的命令行基于 `commander` 这个插件构建，熟悉这个插件的同学很容易看懂 FIS 命令行相关部分源码。

2、FIS 以 `fis-kernel` 为核心。`fis-kernel` 提供了 FIS 的底层能力，包含了一系列模块，如配置、缓存、文件处理、日志等。FIS 的三个命令，最终调用了这些模块来完成构建的任务。参考 `fis-kernel/lib/` 目录，下面对每个模块的大致作用做了简单备注，后面的文章再详细展开。

```html
lib/
├── cache.js    &lt;span class="comment">// 缓存模块，提高编译速度&lt;/span>
├── compile.js    &lt;span class="comment">// （单）文件编译模块&lt;/span>
├── config.js  &lt;span class="comment">// 配置模块，fis.config &lt;/span>
├── file.js  &lt;span class="comment">// 文件处理&lt;/span>
├── log.js &lt;span class="comment">// 日志&lt;/span>
├── project.js  &lt;span class="comment">// 项目相关模块，比如获取、设置项目构建根路径、设置、获取临时路径等&lt;/span>
├── release.js  &lt;span class="comment">// fis release 的时候调用，依赖 compile.js 完成单文件编译。同时还完成如文件打包等任务。├── uri.js  // uri相关&lt;/span>
└── util.js  &lt;span class="comment">// 各种工具函数&lt;/span>
 
```

3、FIS 的编译过程，最终可以拆解为细粒度的[单文件编译](http://fis.baidu.com/docs/more/fis-base.html#%E5%8D%95%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B)，理解了下面这张图，对于阅读 FIS 的源码有非常大的帮助。（主要是 `fis release` 这个命令）

![enter image description here](https://raw.githubusercontent.com/fouber/fis-wiki-img/master/workflow.png)

## 一个简单的例子：fis server open

开篇的描述可能比较抽象，下面我们来个实际的例子。通过这个简单的例子，我们可以对 FIS 的整体设计有个大致的印象。

下文以 `fis server open` 为例，逐步剖析 FIS 的整体设计。其实 FIS 比较精华的部分集中在 `fis release` 这个命令，不过 `fis server` 这个命令相对简单，更有助于我们从纷繁的细节中跳出来，窥探 FIS 的整体概貌。

假设我们已经安装了 FIS。好，打开控制台，输入下面命令，其实就是打开 FIS 的 server 目录

    fis server open
     

从 `package.json` 可以知道，此时调用了 `fis/bin/fis`，里面只有一行有效代码，调用 `fis.cli.run()`方法，同时将进程参数传进去。

```html
&lt;span class="comment">#!/usr/bin/env node&lt;/span>
 
&lt;span class="keyword">require&lt;/span>(&lt;span class="string">'../fis.js'&lt;/span>).cli.run(process.argv);
 
```

接下来看下`../fis.js`。代码结构非常清晰。注意，笔者将一些代码给去掉，避免长串的代码影响理解。同时在关键处加了简单的注释

```html
&lt;span class="comment">// 加载FIS内核&lt;/span>
&lt;span class="keyword">var&lt;/span> fis = module.exports = &lt;span class="keyword">require&lt;/span>(&lt;span class="string">'fis-kernel'&lt;/span>);
 
&lt;span class="comment">//项目默认配置&lt;/span>
fis.config.merge({
   &lt;span class="comment">// ...&lt;/span>
});
 
&lt;span class="comment">//exports cli object&lt;/span>
&lt;span class="comment">// fis命令行相关的对象&lt;/span>
fis.cli = {};
 
&lt;span class="comment">// 工具的名字。在基于fis的二次解决方案中，一般会将名字覆盖&lt;/span>
fis.cli.name = &lt;span class="string">'fis'&lt;/span>;
 
&lt;span class="comment">//colors&lt;/span>
&lt;span class="comment">// 日志友好的需求&lt;/span>
fis.cli.colors = &lt;span class="keyword">require&lt;/span>(&lt;span class="string">'colors'&lt;/span>);
 
&lt;span class="comment">//commander object&lt;/span>
&lt;span class="comment">// 其实最后就挂载了 commander 这个插件&lt;/span>
fis.cli.commander = &lt;span class="keyword">null&lt;/span>;
 
&lt;span class="comment">//package.json&lt;/span>
&lt;span class="comment">// 把package.json的信息读进来，后面会用到&lt;/span>
fis.cli.info = fis.util.readJSON(__dirname + &lt;span class="string">'/package.json'&lt;/span>);
 
&lt;span class="comment">//output help info&lt;/span>
&lt;span class="comment">// 打印帮助信息的API&lt;/span>
fis.cli.help = &lt;span class="keyword">function&lt;/span>(){
    &lt;span class="comment">// ...&lt;/span>
};
 
&lt;span class="comment">// 需要打印帮助信息的命令，在 fis.cli.help() 中遍历到。 如果有自定义命令，并且同样需要打印帮助信息，可以覆盖这个变量&lt;/span>
fis.cli.help.commands = [ &lt;span class="string">'release'&lt;/span>, &lt;span class="string">'install'&lt;/span>, &lt;span class="string">'server'&lt;/span> ];
 
&lt;span class="comment">//output version info&lt;/span>
&lt;span class="comment">// 打印版本信息&lt;/span>
fis.cli.version = &lt;span class="keyword">function&lt;/span>(){
    &lt;span class="comment">// ...&lt;/span>
};
 
&lt;span class="comment">// 判断是否传入了某个参数（search）&lt;/span>
&lt;span class="keyword">function&lt;/span> hasArgv(argv, search){
    &lt;span class="comment">// ...&lt;/span>
}
 
&lt;span class="comment">//run cli tools&lt;/span>
&lt;span class="comment">// 核心方法，构建的入口所在。接下来我们就重点分析下这个方法。假设我们跑的命令是 fis server open&lt;/span>
&lt;span class="comment">// 实际 process.argv为 [ 'node', '/usr/local/bin/fis', 'server', 'open' ]&lt;/span>
&lt;span class="comment">// 那么，argv[2] ==> 'server'&lt;/span>
fis.cli.run = &lt;span class="keyword">function&lt;/span>(argv){
    &lt;span class="comment">// ...&lt;/span>
};
 
```

我们来看下笔者注释过的 `fis.cli.run` 的源码。

1.  如果是 `fis -h` 或者 `fis --help`，打印帮助信息
2.  如果是 `fis -v` 或者 `fis --version`，打印版本信息
3.  其他情况：加载相关命令对应的插件，并执行命令，比如 `fis-command-server`

```html
&lt;span class="comment">//run cli tools&lt;/span>
fis.cli.run = &lt;span class="keyword">function&lt;/span>(argv){
    
    fis.processCWD = process.cwd(); &lt;span class="comment">// 当前构建的路径&lt;/span>
 
    &lt;span class="keyword">if&lt;/span>(hasArgv(argv, &lt;span class="string">'--no-color'&lt;/span>)){    &lt;span class="comment">// 打印的命令行是否单色&lt;/span>
        fis.cli.colors.mode = &lt;span class="string">'none'&lt;/span>;
    }
 
    &lt;span class="keyword">var&lt;/span> first = argv[&lt;span class="number">2&lt;/span>];
    &lt;span class="keyword">if&lt;/span>(argv.length &lt; &lt;span class="number">3&lt;/span> || first === &lt;span class="string">'-h'&lt;/span> ||  first === &lt;span class="string">'--help'&lt;/span>){
        fis.cli.help(); &lt;span class="comment">// 打印帮助信息&lt;/span>
    } &lt;span class="keyword">else&lt;/span> &lt;span class="keyword">if&lt;/span>(first === &lt;span class="string">'-v'&lt;/span> || first === &lt;span class="string">'--version'&lt;/span>){
        fis.cli.version();  &lt;span class="comment">// 打印版本信息&lt;/span>
    } &lt;span class="keyword">else&lt;/span> &lt;span class="keyword">if&lt;/span>(first[&lt;span class="number">0&lt;/span>] === &lt;span class="string">'-'&lt;/span>){
        fis.cli.help(); &lt;span class="comment">// 打印版本信息&lt;/span>
    } &lt;span class="keyword">else&lt;/span> {
        &lt;span class="comment">//register command&lt;/span>
        &lt;span class="comment">// 加载命令对应的插件，这里特指 fis-command-server&lt;/span>
        &lt;span class="keyword">var&lt;/span> commander = fis.cli.commander = &lt;span class="keyword">require&lt;/span>(&lt;span class="string">'commander'&lt;/span>);
        &lt;span class="keyword">var&lt;/span> cmd = fis.&lt;span class="keyword">require&lt;/span>(&lt;span class="string">'command'&lt;/span>, argv[&lt;span class="number">2&lt;/span>]);
        cmd.register(
            commander
                .command(cmd.name || first)
                .usage(cmd.usage)
                .description(cmd.desc)
        );
        commander.parse(argv);  &lt;span class="comment">// 执行命令&lt;/span>
    }
};
 
```

通过 `fis.cli.run` 的源码，我们可以看到，`fis-command-xx` 插件，都提供了 `register` 方法，在这个方法内完成命令的初始化。之后，通过 `commander.parse(argv)`来执行命令。

整个流程归纳如下：

1.  用户输入 FIS 命令，如 `fis server open`
2.  解析命令，根据指令加载对应插件，如 `fis-command-server`
3.  执行命令

## fis-command-server 源码

三个命令相关的插件中，`fis-command-server` 的代码比较简单，这里就通过它来大致介绍下。

根据惯例，同样是抽取一个超级精简版的 `fis-command-server`，这不影响我们对源码的理解

```html
&lt;span class="keyword">var&lt;/span> server = &lt;span class="keyword">require&lt;/span>(&lt;span class="string">'./lib/server.js'&lt;/span>);  &lt;span class="comment">// 依赖的基础库&lt;/span>
 
&lt;span class="comment">// 命令的配置属性，打印帮助信息的时候会用到&lt;/span>
exports.name = &lt;span class="string">'server'&lt;/span>;
exports.usage = &lt;span class="string">'&lt;command> [options]'&lt;/span>;
exports.desc = &lt;span class="string">'launch a php-cgi server'&lt;/span>;
 
&lt;span class="comment">// 对外暴露的 register 方法，参数的参数为 fis.cli.command &lt;/span>
exports.register = &lt;span class="keyword">function&lt;/span>(commander) {
    
    &lt;span class="comment">// 略过若干个函数&lt;/span>
 
    &lt;span class="comment">// 命令的可选参数，格式参考 commander 插件的文档说明&lt;/span>
    commander
        .option(&lt;span class="string">'-p, --port &lt;int>'&lt;/span>, &lt;span class="string">'server listen port'&lt;/span>, parseInt, process.env.FIS_SERVER_PORT || &lt;span class="number">8080&lt;/span>)      
        .action(&lt;span class="keyword">function&lt;/span>(){
            &lt;span class="comment">// 当 command.parse(..)被调用时，就会进入这个回调方法。在这里根据fis server 的子命令执行具体的操作&lt;/span>
            &lt;span class="comment">// ...&lt;/span>
        });
  
    &lt;span class="comment">// 注册子命令 fis server open&lt;/span>
    &lt;span class="comment">// 同理，可以注册 fis server start 等子命令&lt;/span>
    commander
        .command(&lt;span class="string">'open'&lt;/span>)
        .description(&lt;span class="string">'open document root directory'&lt;/span>);
};
 
 
```

好了，`fis server open` 就大致剖析到这里。只要熟悉 `commander` 这个插件，相信不难看懂上面的代码，这里就不多做展开了，有空也写篇科普文讲下 `commander` 的使用。

## 写在后面

如序言所说，欢迎交流探讨。如有错漏，请指出。

文章: casperchen


<!-- {% endraw %} - for jekyll -->