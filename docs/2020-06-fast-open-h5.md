---
title: 大型 h5 页面无缝闪开方案
date: 2020-06-10
author: flyfu wang
source_link: http://www.alloyteam.com/2020/06/fast-open-h5/
---

<!-- {% raw %} - for jekyll -->

在传统的 web 优化中，我们可以采取压缩、拆包、动态加载等方法减少首屏资源大小，也能通过离线包、页面直出等方案加速 html 返回，之前一篇 [h5 秒开大全](http://www.alloyteam.com/2019/10/h5-performance-optimize/)有部分简析。在大部分场景中，这些方案都足够用，也能得到出色的效果。但仍有两种无法尽善尽美的地方：其一是短暂的白屏现象不可避免，其二是对于超大型 web 应用难以做到秒开。结合客户端特性，我们有没有办法，进一步做到极致，打开 web 页面和打开客户端页面无差异的体验呢？  
![](https://docimg2.docs.qq.com/image/8zwAeo1rX71VJztnruHf9g?w=360&h=200)

## 传统方案的困境

无论是 html 离线，还是直出，以及让 webview 启动和网络请求并行 ，页面的切换和打开都无法避免 html 加载这一过程。对于大型应用而言，庞大的 js 初始化解析和执行会耗费巨大的时间。

![enter image description here](http://www.alloyteam.com/wp-content/uploads/2020/06/1591520866_91_w1354_h868.png)

## 新的思考方向？

速度优化的本质是以空间换时间。我们是否可以从这个思路，将打开 webview 及解析 html 这以过程省略掉呢？答案是可以的。

![enter image description here](http://www.alloyteam.com/wp-content/uploads/2020/06/1591521186_83_w1360_h874.png)

## 容器化方案

`容器化`即是我们最终探索与实践的出来的一套方案。正常 web 页面关闭后，webview 组件即会销毁掉，下一次再打开需要重新启动。通常让 webview 保持常驻的做法可以节省 webview 启动时间， 但简单的常驻 webview 并不能做到页面秒开，页面打开仍然需要重新解析 html。

对于我们的应用特征而言，页面切换实际上是仅仅内容数据的变化，比如切换一篇文档，其 html 容器及样式都是同一套，而差异仅仅只是在数据上，重新载入 html 及初始化 js 这部分耗时完全可以避免掉。让 webview 组件及其容器内的 html 页面常驻，在文档切换的过程，仅仅对数据进行替换，这即是容器化方案。容器化方案省去了 webview 重复启动和渲染 html 的问题，打开文档，耗时只在做数据替换，真正做到了秒开。

![enter image description here](http://www.alloyteam.com/wp-content/uploads/2020/06/1591523553_98_w1520_h946.png)

### 容器切换

web 侧如何感知到不同的页面在进行互切换，数据如何做到替换呢？

首先在 app 打开的时候，文档列表会进行数据预拉取，同时触发客户端预启动容器，除此外，其他任意场景也能按需触发容器启动（后面会聊到）。容器内会提前进行 html 渲染和 js 执行，此时的数据是空的。用户点击文档，客户端会对打开 url 这一行为进行监听，同时解析 url，取出唯一标识符， 判断本地是否已经存在并且符合要求的数据，如果条件命中，直接使用已经打开的容器切出，通知到容器内的 web，web 收到通知，通过 url 取出标识符，从本地进行数据获取，然后对数据进行替换渲染，从而完成页面切换。

![enter image description here](http://www.alloyteam.com/wp-content/uploads/2020/06/1591521478_24_w1299_h1277.png)

### 容器化数据替换

直接容器替换的思路省去了代码加载和解析时间，但对于前端代码而言，需要支持直接替换数据。大部分前端项目代码设计都是`自执行调用`方式，支持容器化的前提是：需要对代码改造成可支持`数据组装和销毁`。

```javascript
// 大部分应用加载页面初始化的场景
class App {
    public init() {
     initA();
     initB();
        // 初始化各种模块
        ...
    }
}
 
const app = new App();
app.init();
 
```

自执行调用后，大量的内部依赖模块也依次进行初始化，然后数据常驻在内存中，通常对于加载一个正常网页而言，用户每次都是新开页面，加载 html， 重新进行解析和初始化，并不会带来什么问题。但是按照容器化思路，页面不会重新载入，只进行数据替代，对于大型应用而言意味着成千上万的模块需要支持内存释放和数据切换，一旦没有处理好，会面临严重的内存泄露和代码健壮性问题。如何组织和管理这些代码，支持可插拔式，让整个页面初始化流程都能链式组装，可以进行配置，是进行容器化代码改造的难点。

-   依赖倒置  
    依赖倒置原则的是指内部模块不应该依赖外部模块，底层模块不应该依赖上层模块。  
    哪些才是底层模块，哪些才是上层模块呢？通常而言，越稳定不变逻辑，应该是越底层，越接近用户交互，容易变化的部分是上层。具体层级划分需要分析应用的结构和依赖关系，良好划分层级的应用是容器化改造的前提。
-   职责链模式  
    职责链模式是指每个对象都有接受请求的可能，这些对象连接成一条链，请求沿着这条链的传递，直到有对象处理，这样做的好处是减少接受者和发送者直接的耦合。比如在一个页面加载生命周期中，我们可以让内部模块到外部模块都实现相应的生命周期职责，应用启动和销毁的过程，请求沿着指定链条从外到内传递，也可以按需指定跳跃某个模块，这样大大降低了模块之间的耦合，从而更好的管理代码。

```c
export default interface IRestart{
    emitter: EventEmitter;
    startDestroy(): void;
    destroy(): void;
    restart(): void;
    restartEnd(): void;
    // ...
}
 
```

```javascript
class Page {
    next: PageFlow|null;
    cache: {
        start: (() => Promise<any>)[];
        end: (
```


<!-- {% endraw %} - for jekyll -->