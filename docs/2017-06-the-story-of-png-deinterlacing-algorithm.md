---
title: png 的故事：隔行扫描算法
date: 2017-06-21
author: june01
source_link: http://www.alloyteam.com/2017/06/the-story-of-png-deinterlacing-algorithm/
---

<!-- {% raw %} - for jekyll -->

## 前言

前文已经讲解过如何解析一张 png 图片，然而对于扫描算法里只是说明了逐行扫描的方式。其实 png 还支持一种隔行扫描技术，即 Adam7 隔行扫描算法。

## 优劣

使用隔行扫描有什么好处呢？如果大家有去仔细观察的话，会发现网络上有一些 png 图在加载时可以做到先显示出比较模糊的图片，然后逐渐越来越清晰，最后显示出完整的图片，类似如下效果：

![Adam7 效果](http://www.alloyteam.com/wp-content/uploads/2017/03/Adam7_make_awesome_face.gif)

这就是隔行扫描能带来的效果。隔行扫描一共会进行 1 到 7 次扫描，每一次都是跳着部分像素点进行扫描的，先扫描到像素点可以先渲染，每多一次扫描，图片就会更清晰，到最后一次扫描时就会扫描完所有像素点，进而渲染出完整的图片。

当然，也因为要进行跳像素扫描，整张图片会存储更多额外数据而导致图片大小会稍微变大，具体增加了什么额外数据下文会进行讲解。

## 生成

要导出一张基于 Adam7 隔行扫描的 png 图片是非常简单，我们可以借助 Adobe 的神器 ——PhotoShop（以下简称 ps）。我们把一张普通的图片拖入到 ps 中，然后依次点选【文件】-【存储为 Web 所用的格式】，在弹出的框里选择存储为 `PNG-24`，然后勾选**交错**，最后点击存储即可。

这里的交错就是只将扫描算法设为 Adam7 隔行扫描，如果不勾选交错，则是普通逐行扫描的 png 图片。

## 原理

Adam7 隔行扫描算法的原理并不难，本质上是将一张 png 图片拆分成多张 png 小图，然后对这几张 png 小图进行普通的逐行扫描解析，最后将解析出来的像素数据按照一定的规则进行归位即可。

### 分析

在解压缩完图像数据后就要马上进行拆图。拆图并不难，就是将原本存储图像数据的 Buffer 数组拆分成多个 Buffer 数组而已。关键的问题是怎么拆，这时我们先祭上 wiki 上这张图：

![原理](http://www.alloyteam.com/wp-content/uploads/2017/03/Adam7_passes.gif)

上面这张图就说明了每次扫描需要扫描到的像素，正常来说一张基于 Adam7 隔行扫描的 png 图片是要经历 7 次扫描的，不过有些比较小的图片的实际扫描次数不到 7 次，这是因为有些扫描因为没有实际像素点而落空的原因，所以下面的讲解还是以标准的 7 次扫描来讲解，本质上此算法的代码写出来后，是能兼容任何大小的 png 图片的，因为算法本身和图片大小无关。

7 次扫描，其实就回答了上面拆图的问题：要拆成 7 张小图。每张小图就包含了每次扫描时要归位的像素点。

以第一次扫描为例：第一次扫描的规则是从左上角（我们设定此坐标为 (0,0)）开始，那么它扫描到的下一个点是同一行上一个点往右偏移 8 个像素，即 (8,0)。以此类推，再下一个点就是 (16,0)、（24,0）等。当当前行所有符合规则的点都扫描完时则跳到下一个扫描行的起点，即 (8,0)，也就是说第一次扫描的扫描行也是以 8 个像素为偏移单位的。直到所有扫描行都已经扫描完成，我们就可以认为这次扫描已经结束，可以考虑进入第二次扫描。

我们以一张 10\*10 大小的 png 图片来举例，下面每个数字代表一个像素点，数字的值代表这个点在第几次扫描时被扫描到：

     1 6 4 6 2 6 4 6 1 6
     7 7 7 7 7 7 7 7 7 7
     5 6 5 6 5 6 5 6 5 6
     7 7 7 7 7 7 7 7 7 7
     3 6 4 6 3 6 4 6 3 6
     7 7 7 7 7 7 7 7 7 7
     5 6 5 6 5 6 5 6 5 6
     7 7 7 7 7 7 7 7 7 7
     1 6 4 6 2 6 4 6 1 6
     7 7 7 7 7 7 7 7 7 7
     

按照规则，在第一次扫描时我们会扫描到 4 个像素点，我们把这 4 个像素点单独抽离出来合在一起，就是我们要拆的第一张小图：

    (1


<!-- {% endraw %} - for jekyll -->