---
title: Web Worker 文献综述
date: 2020-07-21
author: TAT. cntchen
source_link: http://www.alloyteam.com/2020/07/14680/
---

<!-- {% raw %} - for jekyll -->

![Title Image](http://alloyteam.com/wp-content/uploads/2020/07/do-something-by-worker.jpg)

# Web Worker 文献综述

> [Web Worker](https://en.wikipedia.org/wiki/Web_worker) 作为浏览器多线程技术，在页面内容不断丰富，功能日趋复杂的当下，成为缓解页面卡顿，提升应用性能的可选方案.  
>
> 但她的容颜，隐藏在边缘试探的科普文章和不知深浅的兼容性背后；对 JS 单线程面试题倒背如流的前端工程师，对多线程开发有着天然的陌生感.

![](http://alloyteam.com/wp-content/uploads/2020/07/1_worker-logo.png)

_⇈[图片来源](https://www.freecodecamp.org/news/how-web-workers-can-help-with-consistent-asynchronous-tasks-in-javascript-cd6d728fa4ee/)_

## 背景

### 文献综述

`文献综述`(Literature Review) 是学术研究领域一个常见概念，写过毕业论文的同学应该还有印象。它向读者介绍与主题有关的详细资料、动态、进展、展望以及对以上方面的评述.

近期笔者关注 Web Worker, 并落地到了**大型复杂前端项目**. 开源了 Worker 通信框架 [alloy-worker](https://github.com/AlloyTeam/alloy-worker), 正在写实践总结文章。其间查阅了相关资料 (50 + 文章，10 + 技术演讲), 独立写成这篇综述性文章.

### 主要内容

-   [Worker 发展历史](http://www.alloyteam.com/2020/07/14680/#发展历史)
-   [主线程和多线程](http://www.alloyteam.com/2020/07/14680/#主线程和多线程)
-   [Worker 应用场景](http://www.alloyteam.com/2020/07/14680/#应用场景)
-   [语法和运行环境](http://www.alloyteam.com/2020/07/14680/#Worker%5C%20API)
-   [Worker 通信速度](http://www.alloyteam.com/2020/07/14680/#通信速度)
-   [浏览器兼容性](http://www.alloyteam.com/2020/07/14680/#兼容性)
-   [调试工具用法](http://www.alloyteam.com/2020/07/14680/#调试工具用法)
-   [社区配套工具](http://www.alloyteam.com/2020/07/14680/#社区配套工具)
-   [业界实践回顾](http://www.alloyteam.com/2020/07/14680/#业界实践回顾)
-   [实践建议和总结](http://www.alloyteam.com/2020/07/14680/#实践建议)

## 发展历史

### 简介

前端同学对 Web Worker 应该不陌生，即使没有动手实践过，应该也在社区上看过相关文章。在介绍和使用上，官方文档是 [MDN 的 Web Workers API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API). 其对 Web Worker 的表述是:

> Web Workers makes it possible to run a script operation in a **background thread** separate from the main execution thread of a web application.

如下图所示，Web Worker 实现了多线程运行 JS 能力。之前页面更新要先**串行 (Serial)** 做 2 件事情；使用 Worker 后，2 件事情可**并行 (Parallel)** 完成.

![](http://alloyteam.com/wp-content/uploads/2020/07/2_worker-thread.jpg)

_⇈[图片来源](https://www.zcfy.cc/original/introduction-to-web-workers-in-javascript)_

可以直观地联想：并行可能会**提升执行效率**; 运行任务拆分能**减少页面卡顿**. 后面[应用场景](http://www.alloyteam.com/2020/07/14680/#应用场景)章节将继续讨论.

### 技术规范

Web Worker 属于 HTML 规范，规范文档见 [Web Workers Working Draft](https://www.w3.org/TR/workers/), 有兴趣的同学可以读一读。而它并不是很新的技术，如下图所示: **2009 年就提出了草案**.

![](https://cntchen.github.io/img/worker-review/worker-history-from-2009.jpg)

_⇈[图片来源](https://www.w3.org/TR/workers/)_

同年在 [FireFox3.5](https://en.wikipedia.org/wiki/Firefox_3.5) 上率先实现，可以在 [using web workers: working smarter, not harder](https://hacks.mozilla.org/2009/07/working-smarter-not-harder/) 中看到早期的实践. 2012 年发布的 [IE10](https://en.wikipedia.org/wiki/Internet_Explorer_10) 也实现了 Web Worker, 标志着主流浏览器上的全面支持. IE10 的 Web Worker 能力测试如下图所示:

![](https://cntchen.github.io/img/worker-review/ie10-worker-ability.png)

_⇈[图片来源](https://alloyteam.github.io/alloy-worker/)_

在预研 Worker 方案时，开发人员会有**兼容性顾虑**. 这种顾虑的普遍存在，主要由于业界 Worker 技术实践较少和社区推广不活跃。单从发展历史看，Worker 从 2012 年起就广泛可用；后面[兼容性](http://www.alloyteam.com/2020/07/14680/#兼容性)章节将继续讨论.

### DedicatedWorker 和 SharedWorker

Web Worker 规范中包括: [DedicatedWorker](https://developer.mozilla.org/en-US/docs/Web/API/Worker) 和 [SharedWorker](https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker); 规范并不包括 Service Worker, 本文也不会展开讨论.

![](http://alloyteam.com/wp-content/uploads/2020/07/two-worker-type.png)

_⇈[图片来源](https://docs.google.com/document/d/1i3IA3TG00rpQ7MKlpNFYUF6EfLcV01_Cv3IYG_DjF7M/edit#heading=h.7smox3ra3f6n)_

如上图所示，DedicatedWorker 简称 Worker, 其线程只能与一个页面渲染进程 (Render Process) 进行绑定和通信，不能多 Tab 共享. DedicatedWorker 是**最早实现并最广泛支持**的 Web Worker 能力.

而 SharedWorker 可以在多个浏览器 Tab 中访问到同一个 Worker 实例，实现多 Tab 共享数据，共享 webSocket 连接等。看起来很美好，但 [safari 放弃了 SharedWorker 支持](https://news.ycombinator.com/item?id=20190869), 因为 [webkit 引擎的技术原因](https://bugs.webkit.org/show_bug.cgi?id=116359). 如下图所示，只在 safari 5~6 中短暂支持过.

![](https://cntchen.github.io/img/worker-review/shared-worker-caniuse.jpg)

_⇈[图片来源](https://caniuse.com/#search=sharedworker)_

社区也在讨论 [是否继续支持 SharedWorker](https://github.com/whatwg/html/issues/315); 多 Tab 共享资源的需求建议在 Service Worker 上寻找方案.

相比之下，DedicatedWorker 有着更广的兼容性和更多业务落地实践，本文后面讨论中的 Worker 都是特指 DedicatedWorker.

## 主线程和多线程

用户使用浏览器一般会打开多个页面 (多 Tab), 现代浏览器[使用单独的进程 (Render Process) 渲染每个页面](https://developers.google.com/web/updates/2018/09/inside-browser-part1), 以提升页面性能和稳定性，并进行操作系统级别的内存隔离.

![](http://alloyteam.com/wp-content/uploads/2020/07/render-process.png)

_⇈[图片来源](https://developers.google.com/web/updates/2018/09/inside-browser-part1)_

### 主线程 (Main Thread)

页面内，内容渲染和用户交互主要由 Render Process 中的[主线程](https://developer.mozilla.org/en-US/docs/Glossary/Main_thread)进行管理。主线程渲染页面每一帧 (Frame), 如下图所示，会包含 [5 个步骤](https://developers.google.com/web/fundamentals/performance/rendering#the_pixel_pipeline): JavaScript → Style → Layout → Paint → Composite, 如果 JS 的执行修改了 DOM, 可能还会暂停 JS, 插入并执行 Style 和 Layout.

![](http://alloyteam.com/wp-content/uploads/2020/07/1_main-thread.jpg)

_⇈[图片来源](https://developers.google.com/web/fundamentals/performance/rendering#the_pixel_pipeline)_

而我们熟知的 [JS 单线程和 Event Loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop), 是主线程的一部分. JS 单线程执行避免了多线程开发中的复杂场景 (如竞态和死锁). 但单线程的主要困扰是：主线程同步 JS 执行耗时过久时 (浏览器理想帧间隔约 16ms), **会阻塞用户交互和页面渲染**.

![](http://alloyteam.com/wp-content/uploads/2020/07/4_js-page-jank.png)

_⇈[图片来源](https://developers.google.com/web/updates/2018/09/inside-browser-part3)_

如上图所示，长耗时任务执行时，页面将无法更新，也无法响应用户的输入 / 点击 / 滚动等操作。如果卡死太久，浏览器可能会抛出卡顿的提示。如下图所示.

-   Chrome81

![](http://alloyteam.com/wp-content/uploads/2020/07/chrome-wait.jpg)

-   IE11

![](https://cntchen.github.io/img/worker-review/ie-no-responding.jpg)

### 多线程

Web Worker 会创建**操作系统级别的线程**.

> The Worker interface spawns **real OS-level threads**. -- [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)

JS 多线程，是有独立于主线程的 JS 运行环境。如下图所示: Worker 线程有独立的内存空间，Message Queue, Event Loop, Call Stack 等，线程间通过 postMessage 通信.

![](http://alloyteam.com/wp-content/uploads/2020/07/2_worker-event-loop.jpg)

多个线程可以并发运行 JS. 熟悉 JS 异步编程的同学可能会说，`setTimeout` / `Promise.all` 不就是并发吗，我写得可溜了.

JS 单线程中的 "并发", 准确来说是 `Concurrent`. 如下图所示，运行时**只有一个函数调用栈**, 通过 Event Loop 实现不同 Task 的上下文切换 (Context Switch). 这些 Task 通过 BOM API 调起其他线程为主线程工作，但回调函数代码逻辑**依然由 JS 串行运行**.

Web Worker 是 JS 多线程运行技术，准确来说是 `Parallel`. 其与 `Concurrent` 的区别如下图所示: Parallel 有多个函数调用栈，每个函数调用栈可以独立运行 Task, 互不干扰.

![](http://alloyteam.com/wp-content/uploads/2020/07/2_concurrency-parallel.jpg)

## 应用场景

讨论完主线程和多线程，我们能更好地理解 Worker 多线程的应用场景:

-   可以减少主线程卡顿.
-   可能会带来性能提升.

### 减少卡顿

根据 Chrome 团队提出的用户感知性能模型 [RAIL](https://web.dev/rail/), 同步 JS 执行时间不能过长。量化来说，播放动画时建议小于 16ms, 用户操作响应建议小于 100ms, 页面打开到开始呈现内容建议小于 1000ms.

#### 逻辑异步化

减少主线程卡顿的主要方法为[异步化执行](https://developers.google.com/web/updates/2018/09/inside-browser-part3), 比如播放动画时，将同步任务拆分为多个小于 16ms 的子任务，然后在页面每一帧前通过 `requestAnimationFrame` 按计划执行一个子任务，直到全部子任务执行完毕.

![](http://alloyteam.com/wp-content/uploads/2020/07/js-chunk-raf.png)

_⇈[图片来源](https://developers.google.com/web/updates/2018/09/inside-browser-part3)_

拆分同步逻辑的异步方案对大部分场景有效果，但并不是一劳永逸的银弹。有以下几个问题:

-   **不是所有 JS 逻辑都可拆分.** 比如数组排序，树的递归查找，图像处理算法等，执行中需要维护当前状态，且调用上非线性，无法轻易地拆分为子任务.
-   **可以拆分的逻辑难以把控粒度.** 如下图所示，拆分的子任务在高性能机器 (iphoneX) 上可以控制在 16ms 内，但在性能落后机器 (iphone6) 上就超过了 deadline. 16ms 的用户感知时间，并不会因为用户手上机器的差别而变化，Google 给出的建议是[再拆小到 3-4ms](https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution#reduce_complexity_or_use_web_workers).

![](https://cntchen.github.io/img/worker-review/beyond-16ms.jpg)

_⇈[图片来源](https://www.youtube.com/watch?v=7Rrv9qFMWNM)_

-   **拆分的子任务并不稳定.** 对同步 JS 逻辑的拆分，需要根据业务场景寻找原子逻辑，而原子逻辑会跟随业务变化，每次改动业务都需要去 review 原子逻辑.

#### Worker 一步到位

Worker 的多线程能力，使得同步 JS 任务的拆分一步到位: **从宏观上将整个同步 JS 任务异步化**. 不需要再去苦苦寻找原子逻辑，逻辑异步化的设计上也更加简单和可维护.

这给我们带来更多的想象空间。如下图所示，在浏览器主线程渲染周期内，将可能阻塞页面渲染的 JS 运行任务 (Jank Job) 迁移到 Worker 线程中，进而减少主线程的负担，缩短渲染间隔，减少页面卡顿.

![](https://cntchen.github.io/img/worker-review/multi-thread-jank.jpg)

### 性能提升

Worker 多线程并不会直接带来计算性能的提升，能否提升与设备 CPU 核数和线程策略有关.

#### 多线程与 CPU 核数

CPU 的单核 (Single Core) 和多核 (Multi Core) 离前端似乎有点远了。但在页面上运用多线程技术时，核数会影响线程创建策略.

进程是操作系统**资源分配**的基本单位，线程是操作系统**调度 CPU** 的基本单位。操作系统对线程能占用的 CPU 计算资源有[复杂的分配策略](https://zhuanlan.zhihu.com/p/97071815). 如下图所示:

-   单核多线程通过时间切片交替执行.
-   多核多线程可在不同核中真正并行.

![](https://cntchen.github.io/img/worker-review/single-vs-multi-core.jpg)

#### Worker 线程策略

一台设备上相同任务在各线程中运行耗时是一样的。如下图所示：我们将主线程 JS 任务交给新建的 Worker 线程，任务在 Worker 线程上运行并不会比原本主线程更快，而线程新建消耗和通信开销使得渲染间隔可能变得更久.

![](https://cntchen.github.io/img/worker-review/single-core-more-time.gif)

_⇈[图片来源](https://www.youtube.com/watch?v=7Rrv9qFMWNM)_

在单核机器上，**计算资源是内卷的**, 新建的 Worker 线程并不能为页面争取到更多的计算资源。在多核机器上，新建的 Worker 线程和主线程都�


<!-- {% endraw %} - for jekyll -->