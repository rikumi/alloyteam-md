---
title: 线程入门
date: 2020-07-15
author: TAT.vorshen
source_link: http://www.alloyteam.com/2020/07/14657/
---

<!-- {% raw %} - for jekyll -->

# 导语

最近团队进行了一些线程的讨论，这里抽空水了一篇关于线程的文章，希望给没接触过线程相关知识的同学入个门。

# 线程是什么

### 进程

既然要说线程，那就不得不提它的两个好兄弟，进程、协程。  
进程大家应该是最了解的，平时用的 ps 命令就是查看计算机中的进程情况，进程的特点：

1、独立，资源（内存）隔离，互不干扰

2、拥有自己的生命周期和状态

让人又爱又恨的 chrome，每个 tab 在默认情况下是单独的进程，流畅是真的，内存大户也是真的。

### 线程

结合进程的特点，可以显而易见发现进程的劣势在于资源的同步，因为互相隔离，无法共享内存，那样一些数据共享的场景，就需要借助比如管道、Signal、Socket 等手段来完成，增加了成本。

线程就可以解决上述场景，线程是进程的组成部分，它拥有的资源都是来自于进程，也就意味着同一个进程下的不同线程，资源是共享的。

_进程中单线程和多线程的区别_

![进程中单线程和多线程的区别](https://raw.githubusercontent.com/vorshen/blog/master/thread/assets/process_thread.png)

### 协程

线程虽然解决了资源的问题，但是它和进程在底层上都是交给操作系统去管理，cpu 不仅仅要关注进程上下文的切换，也需要考虑线程之间的切换，每一次切换都是性能的开销。

一个优秀的程序员可以不脱发，但是不能不追求性能，所以协程应运而生。协程的特点就是它是应用层面的，不再交由操作系统去切换处理，由开发者自己控制，减少上下文切换开销。

go 中的 goroutine 就算是一种特殊的协程，大概代码如下

```go
// ...package import
func fibonacci(i int64, endChan chan<- bool) {
    result := calc(i)
 
    fmt.Printf("Result: %d \n", result)
 
    endChan <- true
}
 
func calc(i int64) int64 {
    if i < 3 {
        return 1
    }
 
    return (calc(i-1) + calc(i-2))
}
 
func main() {
    endChan := make(chan bool)
 
    for i := 0; i < 5; i++ {
        go fibonacci(int64(i*10), endChan)
    }
 
    for i := 0; i < 5; i++ {
        <-endChan
    }
 
    fmt.Printf("Thread End")
}
```

感兴趣的可以自行了解

# 多线程编程

### Hello World

上面从刚刚介绍了进程、线程、协程的区别，下面就开始真正的线程介绍。Talk is cheap. Show me the code。

我们用斐波拉切数列为例，使用 C++ 和 Javascript 展示一下多线程计算。

C++


<!-- {% endraw %} - for jekyll -->