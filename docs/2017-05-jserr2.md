---
title: 脚本错误量极致优化 - 让脚本错误一目了然
date: 2017-05-05
author: TAT.joeyguo
source_link: http://www.alloyteam.com/2017/05/jserr2/
---

<!-- {% raw %} - for jekyll -->

[原文地址](https://github.com/joeyguo/blog/issues/14)

在上篇 [《脚本错误量极致优化 - 监控上报与 Script error》](https://github.com/joeyguo/blog/issues/13) 中，主要提到了 js 脚本错误上报的方式，并讲解了如何使用 crossorigin 来解决 Script error 报错信息的方案，于是我们就可以查看到脚本报错信息了。而此时可能会遇到另一个问题：**”JS 代码压缩后，定位具体出错代码困难！“**。本篇 [《脚本错误量极致优化 - 让脚本错误一目了然》](https://github.com/joeyguo/blog/issues/14) 将结合示例，通过多种解决方案逐一分析，让脚本错误 一目了然。  

## 示例・压缩代码定位错误困难

1. 源代码（存在错误）

```javascript
function test() {
    noerror; // <- 报错
}
test();
```

2. 经 webpack 打包压缩后产生如下代码

```javascript
!(function (n) {
    function r(e) {
        if (t[e]) return t[e].exports;
        var o = (t[e] = { i: e, l: !1, exports: {} });
        return n[e].call(o.exports, o, o.exports, r), (o.l = !0), o.exports;
    }
    var t = {};
    (r.m = n),
        (r.c = t),
        (r.i = function (n) {
            return n;
        }),
        (r.d = function (n, t, e) {
            r.o(n, t) ||
                Object.defineProperty(n, t, {
                    configurable: !1,
                    enumerable: !0,
                    get: e,
                });
        }),
        (r.n = function (n) {
            var t =
                n && n.__esModule
                    ? function () {
                          return n.default;
                      }
                    : function () {
                          return n;
                      };
            return r.d(t, "a", t), t;
        }),
        (r.o = function (n, r) {
            return Object.prototype.hasOwnProperty.call(n, r);
        }),
        (r.p = ""),
        r((r.s = 0));
})([
    function (n, r) {
        function t() {
            noerror;
        }
        t();
    },
]);
```

3. 代码如期报错，并上报相关信息


<!-- {% endraw %} - for jekyll -->