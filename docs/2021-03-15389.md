---
title: æ·±å…¥å­¦ä¹ å®šæ—¶å™¨
date: 2021-03-02
author: TAT.vorshen
source_link: http://www.alloyteam.com/2021/03/15389/
---

<!-- {% raw %} - for jekyll -->

æˆ–è®¸åœ¨ç”Ÿæ´»ä¸­å¤§å®¶éƒ½è®¨åŒå®šæ—¶å™¨ï¼Œæ¯”å¦‚å‘¨ä¸€æ—©ä¸Šçš„é—¹é’Ÿã€æ‰¿è¯ºè€æ¿ç¬¬äºŒå¤©ä¸€æ—©ç»™æŠ¥å‘Šçš„ deadlineï¼›ä½†æ˜¯åœ¨ä»£ç çš„ä¸–ç•Œé‡Œï¼Œå®šæ—¶å™¨æ‰®æ¼”ç€ä¸å¯æˆ–ç¼ºçš„è§’è‰²ï¼šå®šæ—¶ä»»åŠ¡ã€è¶…æ—¶åˆ¤æ–­ã€å¸§åŒæ­¥ç­‰ç­‰ã€‚  
é‚£å®šæ—¶å™¨çš„æœ¬è´¨æ˜¯ä»€ä¹ˆï¼Ÿæˆ‘ä»¬ä½¿ç”¨çš„å®šæ—¶èƒ½åŠ›èƒŒååˆæš—è—ç€ä»€ä¹ˆç„æœºï¼Œè¯·ç»§ç»­å¾€ä¸‹çœ‹ã€‚

æ³¨æ„ï¼šç”±äºåšå®¢ç³»ç»Ÿé—®é¢˜å¯¼è‡´æ’ç‰ˆæœ‰ç‚¹å¼‚å¸¸ï¼Œæ¥å—ä¸äº†çš„å¯ä»¥çœ‹ <https://github.com/vorshen/blog/blob/master/timer/index.md>

## ç›®å½•

### [å®šæ—¶èƒ½åŠ›éœ€è¦ä»€ä¹ˆ](http://www.alloyteam.com/2021/03/15389/#å®šæ—¶èƒ½åŠ›éœ€è¦ä»€ä¹ˆ)

### [ä¿¡å·](http://www.alloyteam.com/2021/03/15389/#ä¿¡å·æ–¹æ¡ˆ)

### [POSIX Timer](http://www.alloyteam.com/2021/03/15389/#POSIX)

### [å¤šè·¯å¤ç”¨](http://www.alloyteam.com/2021/03/15389/#å¤šè·¯å¤ç”¨)

## å®šæ—¶èƒ½åŠ›éœ€è¦ä»€ä¹ˆ

javascript çš„å®šæ—¶å™¨èƒ½åŠ›åº”è¯¥æ˜¯ä½¿ç”¨æœ€ä¸ºæ–¹ä¾¿ï¼Œé»˜è®¤çš„ä¸Šä¸‹æ–‡æ•è·ï¼Œå‡½æ•°å¼ç¼–ç¨‹ã€‚

```javascript
setTimeout(function () {
    console.log("åˆ©åˆ©å–å¤šäº†");
}, 3000);
console.log("åˆ©åˆ©å¨å¨å¨");
```

æˆ‘ä»¬å¯ä»¥æŠŠ setTimeout çš„æ‰§è¡Œï¼Œæ‹†è§£ä¸€ä¸‹ï¼Œä¸»è¦æ˜¯ä»¥ä¸‹çš„æµç¨‹ã€‚  
![setTimeout æ‰§è¡Œä¾èµ–](https://raw.githubusercontent.com/vorshen/blog/master/timer/assets/1.png)  
ä¸»è¦æœ‰ä¸‰ä¸ªç¯èŠ‚:

1.  å­˜æ”¾ callback
2.  å¯åŠ¨ä¸€ä¸ªå€’è®¡æ—¶
3.  å€’è®¡æ—¶ç»“æŸï¼Œå–å‡ºå­˜å¥½çš„ callbackï¼ŒRUNï¼

_BTW: JS ä¸­å®šæ—¶å™¨è¿™ä¹ˆæ–¹ä¾¿ï¼Œä¸ä»…ä»…æ˜¯ v8 çš„åŠŸåŠ³ï¼Œè¿˜éœ€è¦æ‰§è¡Œç¯å¢ƒ (eg: chromeã€node) ç»™äºˆæ”¯æŒã€‚å¦‚æœç”¨ d8 å»è°ƒè¯•ï¼Œä¼šå‘ç° setTimeout å¹¶æ²¡æœ‰å®šæ—¶æ‰§è¡Œã€‚_

æ ¸å¿ƒéœ€è¦è§£å†³ 1ï¼Œ2 ä¸¤ä¸ªé—®é¢˜ï¼Œå…ˆçœ‹å­˜æ”¾ callbackï¼Œè¿™é‡Œæ€»ç»“ä¸€ä¸‹å­˜æ”¾çš„ç‰¹ç‚¹:

-   ä¸Šå±‚è®¾ç½®å®šæ—¶ä»»åŠ¡çš„é¡ºåºæ˜¯ä¸ç¡®å®šçš„ï¼Œè€Œæœ€ç»ˆçš„æ‰§è¡Œæ˜¯æœ‰é¡ºåºçš„ï¼Œè¿™é‡Œæ¶‰åŠåˆ°æ’åºè¡Œä¸º
-   è®¾ç½®å®šæ—¶å™¨çš„åŠ¨ä½œå¯èƒ½æ˜¯å¤šæ¬¡çš„  
    **æ»¡è¶³ç”±ä¸Šæ¡ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªå°æ ¹å †çš„æ•°æ®ç»“æ„æ¥å­˜æ”¾ callbackã€‚**

_BTW: ä¹Ÿæœ‰ä¸€ç§æ—¶é—´è½®çš„æ–¹æ¡ˆï¼Œlibco ä¸­é‡‡å–æ—¶é—´è½®æ–¹æ¡ˆã€‚_

é‚£ä¹ˆè¯¥å¦‚ä½•å¯åŠ¨ä¸€ä¸ªå€’è®¡æ—¶çš„é’Ÿæ‘†å‘¢ï¼Ÿ**ä»ç¼–ç¨‹è¯­è¨€å±‚é¢æ˜¯æ²¡æœ‰å€’è®¡æ—¶ç›¸å…³ api çš„**ï¼Œè¿˜å¥½æ“ä½œç³»ç»Ÿå†…æ ¸ç»™äº†æˆ‘ä»¬ä¸€äº›è§£å†³æ–¹æ¡ˆã€‚  
_BTW: å°±å¥½æ¯”è¯´åˆ° Linux ä¸Šå®šæ—¶ä»»åŠ¡ï¼Œå¤§å®¶åŸºæœ¬ä¸Šéƒ½ä¼šæƒ³åˆ° crontabï¼Œè¿™ä¹Ÿæ˜¯å†…æ ¸ç»™æˆ‘ä»¬çš„èƒ½åŠ›çš„ä¸€ç§è¡¨ç°ã€‚_

å†…æ ¸ä¸­å…·ä½“çš„æ—¶é’Ÿèƒ½åŠ›å¦‚ä½•å®ç°ï¼Œä¸æ˜¯æˆ‘ä»¬çš„é‡ç‚¹ï¼Œè¿™ä¼šæ¶‰åŠåˆ° CPU æ—¶é’Ÿä¸­æ–­ï¼Œå†åº•å±‚è¿˜æœ‰ç¡¬ä»¶ç›¸å…³ï¼Œæ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥è‡ªè¡ŒæŸ¥é˜…ã€‚æˆ‘ä»¬é‡ç‚¹æ”¾åœ¨ä»£ç ä¸­å¦‚ä½•å»ä½¿ç”¨æ“ä½œç³»ç»Ÿæä¾›çš„æ—¶é’Ÿèƒ½åŠ›ã€‚  
å¯¹äºç¨‹åºæ¥è¯´ï¼Œæˆ‘ä»¬çš„è¯‰æ±‚å°±æ˜¯è®¾å®šäº†ä¸€ä¸ªæ—¶é—´ï¼Œå½“è¯¥æ—¶é—´åˆ°è¾¾ï¼ˆå¯ä»¥ç†è§£ä¸ºè¶…æ—¶ï¼‰ï¼Œå†…æ ¸å¯ä»¥é€šçŸ¥åˆ°åº”ç”¨ç¨‹åºã€‚é‚£ä¹ˆæœ‰å“ªäº›é€šçŸ¥æ–¹å¼å‘¢ï¼Ÿ

## ä¿¡å·æ–¹æ¡ˆ

é‚£ä¹ˆæˆ‘ä»¬å…ˆçœ‹ä¿¡å·çš„æ–¹æ¡ˆï¼Œä¸€è¯´åˆ°ä¿¡å·ï¼Œå¯èƒ½å°±ä¼šæƒ³åˆ° alarm (_sleep èµ°å¼€_)ï¼Œè¿™é‡Œä¸¾ä¸ªç®€å•çš„ğŸŒ°ã€‚

```c
#include <unistd.h>
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
Â 
int curr = 0;
int max = 3;
Â 
void drink() {
Â Â Â Â printf("åˆ©åˆ©å¨å¨å¨\n");
Â Â Â Â curr++;
Â Â Â Â if (curr < max) {
Â Â Â Â Â Â Â Â alarm(1); // 1s åå‘å‡º SIGALRM ä¿¡å·
Â Â Â Â } else {
Â Â Â Â Â Â Â Â kill(getpid(), SIGINT);
Â Â Â Â }
}
Â 
void sigalrmCallback(int sig) {
Â Â Â Â drink();
}
Â 
void sigintCallback(int sig) {
Â Â Â Â printf("åˆ©åˆ©å–ä¸åŠ¨äº†\n");
Â Â Â Â exit(0);
}
Â 
int main(int argc, char* argv[]) {
Â Â Â Â signal(SIGALRM, sigalrmCallback); // æ—¶é’Ÿå®šæ—¶ä¿¡å·
Â Â Â Â signal(SIGINT, sigintCallback); // ç»ˆæ­¢ä¿¡å·
Â 
Â Â Â Â drink();
Â 
Â Â Â Â while (1) {
Â Â Â Â Â Â Â Â pause(); // ç­‰å¾…ä¿¡å·
Â Â Â Â }
Â Â Â Â return 0;
}
```

ç»“æœå°±ä¸æˆªå›¾äº†ï¼Œä»£ç æ¯”è¾ƒå¥½ç†è§£ï¼Œæ ¸å¿ƒå°±æ˜¯å›´ç»• SIGALRM çš„ç›‘å¬å’Œè§¦å‘ã€‚  
ä¸è¿‡è¿™é‡Œæœ‰ä¸€äº›é—®é¢˜ï¼Œæˆ‘ä»¬ä¸€ä¸€æ¥çœ‹ä¸‹  
Q1: ç²¾åº¦é—®é¢˜ï¼Œç§’ä¸ºç²¾åº¦ï¼Œè¿™å¤ªè‰äº†ï¼Œè‚¯å®šä¸èƒ½æ¥å—  
A1: ä¸è¿‡æˆ‘ä»¬å¯ä»¥ç”¨å…¶ä»–å‡½æ•°ä»£æ›¿ï¼Œæ¯”å¦‚ setitimer _(ç²¾åº¦ä¸ºæ¯«ç§’)_

Q2: æ— æ³•å¤šæ¬¡è°ƒç”¨ alrm  
A2: æˆ‘ä»¬éœ€è¦åŒ…è£…ä¸€å±‚ï¼Œå¤„ç†å¤šæ¬¡è°ƒç”¨çš„æƒ…å†µã€‚

ä¸è¿‡ä¸Šé¢ä¸¤ä¸ªä¸ªé—®é¢˜è¿˜ç®—å¥½è§£å†³ï¼Œé’ˆå¯¹ä»¥ä¸Šä¸¤ä¸ªé—®é¢˜è§£æ³•ï¼Œè¿™é‡Œæœ‰ä¸ªæ”¹ä¸º setitimer ä¼˜åŒ–ç‰ˆæœ¬ï¼Œå¯è§[è¿™é‡Œ](http://www.alloyteam.com/2021/03/15389/example/setitimer/main.cc)ã€‚  
ç»“æœå¦‚ä¸‹å›¾  
![setitimer æ‰§è¡Œç»“æœ](https://raw.githubusercontent.com/vorshen/blog/master/timer/assets/2.png)  
å¯ä»¥çœ‹åˆ°**ç²¾åº¦æé«˜äº†**ï¼Œå¹¶ä¸”**æ”¯æŒäº†å¤šæ¬¡è°ƒç”¨**ã€‚

ä½†æ˜¯åˆ«é«˜å…´çš„å¤ªæ—©ï¼é—®é¢˜è¿˜æ²¡æœ‰ç»“æŸï¼  
Q3: å¤šçº¿ç¨‹æƒ…å†µä¸‹æ€ä¹ˆåŠï¼Ÿ  
A3: ä¿¡å·åœ¨å¤šçº¿ç¨‹ä¸‹å°±æ˜¯ä¸çµæ´»ï¼Œä¸€èˆ¬åšæ³•éœ€è¦ç”¨å•ç‹¬çš„çº¿ç¨‹å»ç›‘å¬ä¿¡å·ï¼Œå…¶ä»–çº¿ç¨‹å±è”½ï¼Œå†™èµ·æ¥å¾ˆéº»çƒ¦ã€‚

Q4: ä¿¡å·å¯é æ€§ï¼Ÿæ— è®ºæ˜¯ alrm è¿˜æ˜¯ setitimer éƒ½æ˜¯å‘é€éå®æ—¶ä¿¡å·ã€‚  
A4: ï¼Ÿï¼Ÿï¼Ÿè¿™å¤ªè‡´å‘½äº†ï¼Œè™½ç„¶æ˜¯æ¦‚ç‡æ€§çš„ï¼Œä½†æ˜¯æ€»æœ‰åœ¨æœºåœºç­‰è‰˜èˆ¹çš„æ„Ÿè§‰ã€‚

æ€»ç»“ä¸€ä¸‹ï¼šä½¿ç”¨ä¿¡å·æ•´ä½“é—®é¢˜è¾ƒå¤šï¼Œè™½ç„¶æˆ‘ä»¬å°è¯•äº†ä¸€äº›è§£å†³æ–¹æ¡ˆï¼Œä½†æ˜¯è¿˜æ˜¯ä¼šå­˜åœ¨æ— è§£çš„é—®é¢˜ï¼Œæ‰€ä»¥è¿™é‡Œä¹Ÿæ²¡æœ‰çœŸå®ä½¿ç”¨ä¿¡å·çš„ä¾‹å­ã€‚

## POSIX

é’ˆå¯¹åˆšåˆšçš„ Q1 åˆ° Q4ï¼Œæ ¹æœ¬æ€§åœ¨äº alrm å’Œ setitmer éƒ½ä¸å¤Ÿå®Œå–„ï¼Œä¸ºæ­¤ POSIX Timer ç›¸å…³å‡½æ•°æä¾›äº†è§£å†³æ–¹æ¡ˆã€‚è¿™ä¸€å°èŠ‚ï¼Œæˆ‘ä»¬ä¸»è¦çœ‹ä¸€ä¸‹ POSIX Timer ç›¸å…³å‡½æ•°ï¼Œéƒ½æ˜¯å¦‚ä½•è§£å†³åˆšåˆšé‚£äº›é—®é¢˜çš„ã€‚

1.  ç²¾åº¦é—®é¢˜  
    POSIX Timer æ”¯æŒç¨‹åº¦æ›´é«˜ï¼Œæ”¯æŒåˆ°çº³ç§’çº§åˆ«ã€‚
2.  æ— æ³•å¤šæ¬¡è°ƒç”¨  
    ä¸€ä¸ªè¿›ç¨‹å¯ä»¥å¤šæ¬¡åˆ›å»º Timerï¼Œç›¸äº’ç‹¬ç«‹ã€‚

    ```c
    #include <unistd.h>
    #include <stdio.h>
    #include <signal.h>
    #include <stdlib.h>
    #include <pthread.h>
    decltype(SIGRTMIN) SIG_DRINK = SIGRTMIN + 1;
    void drink(u_int32_t second) {
    struct sigevent evp;
    timer_t timer;
    Â 
    evp.sigev_notify = SIGEV_SIGNAL;
    evp.sigev_value.sival_ptr = &timer;
    evp.sigev_signo = SIG_DRINK; // è‡ªå®šä¹‰ä¿¡å·
    Â 
    int ret = timer_create(CLOCK_REALTIME, &evp, &timer); // åˆ›å»ºå®šæ—¶å™¨
    if (ret) {
    Â Â Â Â printf("timer_create error\n");
    }
    Â 
    struct itimerspec ts;
    ts.it_value.tv_sec = second / 1000;
    ts.it_value.tv_nsec = (second % 1000) * 1000;
    ts.it_interval.tv_sec = 0;
    ts.it_interval.tv_nsec = 0;
    Â 
    ret = timer_settime(timer, CLOCK_REALTIME, &ts, nullptr); // è®¾ç½®å®šæ—¶å™¨
    if (ret) {
    Â Â Â Â printf("timer_settime error\n");
    }
    }
    int main(int argc, char* argv[]) {
    signal(SIG_DRINK, [](int sig) {
    Â Â Â Â printf("åˆ©åˆ©å¨å¨å¨\n");
    });
    Â 
    drink(3000);
    drink(2000);
    drink(1000);
    Â 
    while (1) {
    Â Â Â Â pause();
    }
    return 0;
    }
    ```

    **å¯ä»¥çœ‹åˆ°è¿™é‡Œå¹¶ä¸éœ€è¦è‡ªå·±å»å¤„ç†å¤šæ¬¡è°ƒç”¨ï¼Œç›´æ¥èµ°åˆ›å»ºå®šæ—¶å™¨ï¼Œè®¾ç½®å®šæ—¶å™¨çš„æµç¨‹å°±è¡Œã€‚**
3.  å¤šçº¿ç¨‹  
    POSIX Timer æä¾›äº†é»˜è®¤èƒ½åŠ›ï¼Œå½“å®šæ—¶å™¨ç»“æŸçš„æ—¶å€™ï¼Œå¯ä»¥å¯åŠ¨çº¿ç¨‹æ‰§è¡Œå¯¹åº”çš„å‡½æ•°ã€‚è€Œä¸”åœ¨ Linux ä¸‹ï¼Œè¿˜æ‰©å±•æä¾›äº†å¾€æŒ‡å®šçº¿ç¨‹å‘é€ä¿¡å·çš„èƒ½åŠ›ã€‚
4.  ä¿¡å·å¯é æ€§  
    POSIX Timer ä¹Ÿå¯ä»¥æŒ‡å®šä¿¡å·ï¼Œä¸è¿‡ä¸å†å±€é™äºéå®æ—¶ä¿¡å·ï¼Œå¯ä»¥é€‰æ‹©å®æ—¶ä¿¡å·ï¼ŒğŸ›«ï¸ã€‚

é’ˆå¯¹ POSIX Timer çš„è°ƒç”¨ï¼Œä¸‹é¢ç”»äº†ä¸€å¼ å›¾  
![POSIX Timer è°ƒç”¨ç›¸å…³](https://raw.githubusercontent.com/vorshen/blog/master/timer/assets/3.png)  
å…·ä½“å‡½æ•°ä½¿ç”¨ã€ç»“æ„ç­‰å¯ä»¥çœ‹å®˜æ–¹æ–‡æ¡£ï¼Œè¿™é‡Œä¹Ÿç»™äº†ä¸€ä¸ªç®€æ˜“å°è£…çš„ä¾‹å­ [posix å°è£…ä¸º setTimeout](http://www.alloyteam.com/2021/03/15389/example/posix/main.cc)ã€‚

_BTW: å…¶å®æœ¬è´¨ä¸Š POSIX Timer ä¹Ÿæ˜¯ä¿¡å·æ–¹æ¡ˆï¼Œå¯ä»¥è§‚å¯Ÿè¿›ç¨‹ä¿¡æ¯ä¸­ä¿¡å·æ•è·ã€‚SIGEV_THREAD æ¨¡å¼ä¸‹ï¼Œä¼šå¯åŠ¨ä¸€ä¸ªè¾…åŠ©çº¿ç¨‹ï¼Œç„¶åä¹Ÿæ˜¯ç›‘å¬åˆ° SIGTIMER ä¿¡å·ï¼Œå†åšåç»­å¤„ç†ï¼Œæºç å¯è§ <https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/timer_routines.c.html>ã€‚_

ç¨å¾®æ€»ç»“ä¸€ä¸‹ï¼ŒPOSIX Timer çš„æ–¹æ¡ˆï¼Œç›¸æ¯”è¾ƒä¹‹å‰å·²ç»å®Œå–„äº†å¾ˆå¤šï¼Œä¸è¿‡è¿˜æœ‰ä¸€äº›ç¼ºç‚¹ã€‚

1.  å°è£…å¤„ç†è¾ƒä¸ºéº»çƒ¦
2.  å¿…é¡»ä¾èµ– librt

ä½¿ç”¨è¯¥æ–¹æ¡ˆçš„å¼€æºé¡¹ç›®æœ‰ gperftoolsï¼Œæ ¸å¿ƒçš„ä»£ç ä½ç½®åœ¨ <https://github.com/gperftools/gperftools/blob/master/src/profile-handler.cc#L282>ã€‚  
å°è£…æ–¹å¼å’Œä¸Šæ–‡ä¸­çš„ä¾‹å­å·®ä¸å¤šï¼Œåªæ˜¯æ¨¡å¼ä¸ä¸€æ ·ï¼Œè¿™é‡Œå°±ä¸è¯¦ç»†è®²è§£äº†ã€‚

## å¤šè·¯å¤ç”¨

å¤šè·¯å¤ç”¨æœ¬èº«æ˜¯ä¸ºäº†è§£å†³æœåŠ¡å™¨é’ˆå¯¹å¤šè¿æ¥æ—¶çš„é˜»å¡é—®é¢˜ï¼Œä¸è¿‡ select/poll/epoll éƒ½æä¾›äº†è¶…æ—¶æ—¶é—´ï¼Œè€Œè¿™ä¸€ç‰¹æ€§å¯ä»¥è®©æˆ‘ä»¬ä½¿ç”¨åˆ°å®šæ—¶å™¨ä¸­ã€‚  
ä»¥ boost çš„ timer ä¸ºä¾‹ï¼Œçœ‹å¦‚ä¸‹ä»£ç 

```javascript
#include <iostream>
#include <boost/asio.hpp>
Â 
int main(int argc, char* argv[]) {
Â Â Â Â std::cout << "åˆ©åˆ©å–ï¼" << std::endl;
Â 
Â Â Â Â boost::asio::io_service io;
Â Â Â Â boost::asio::deadline_timer timer(io, boost::posix_time::seconds(3));
Â Â Â Â timer.wait();
Â 
Â Â Â Â std::cout << "3sååˆ©åˆ©å–ä¸åŠ¨äº†ï¼" << std::endl;
Â 
Â Â Â Â return 0;
}
```

ä»£ç å¾ˆå¥½ç†è§£ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹ boost æ˜¯å¦‚ä½•å®ç°ä¸€ä¸ªåŒæ­¥çš„ timer.wait èƒ½åŠ›çš„ï¼Œé¡ºç€ deadline_timer_service å¯ä»¥æ‰¾åˆ°æœ€åæºç ä½ç½®åœ¨ <https://github.com/boostorg/asio/blob/develop/include/boost/asio/detail/impl/socket_ops.ipp#L2162>ï¼Œç®€å•åˆ°æ— éœ€å¤šä½™è®²è§£ã€‚  
_BTW: å¹¶ä¸”è¿™é‡Œåªç”¨è¶…æ—¶èƒ½åŠ›ï¼Œä¸ç”¨æ‹…å¿ƒ select æœ¬èº«åœ¨å¤šè·¯å¤ç”¨ä¸­çš„æ€§èƒ½é—®é¢˜ã€‚_

boost ä¸­çš„å¼‚æ­¥å®šæ—¶å™¨ï¼Œä¹Ÿæ˜¯é‡‡ç”¨äº†å¤šè·¯å¤ç”¨çš„æ–¹æ¡ˆï¼Œä½¿ç”¨çš„æ˜¯ epollï¼Œå…¶ä¸­ç”¨åˆ°äº† timer_fdï¼Œå…ˆç®€å•çš„è¯´ä¸€ä¸‹ timer_fdã€‚  
**timer_fd æ˜¯ linux2.6.25 åå¢åŠ çš„ apiï¼Œç®—æ˜¯å®˜æ–¹å½¢å¼å°†å®šæ—¶èƒ½åŠ›å’Œ IO äº‹ä»¶ç»“åˆäº†èµ·æ¥ã€‚**  
å¼‚æ­¥å®šæ—¶å™¨ç›¸æ¯”è¾ƒåŒæ­¥å¤æ‚å¾ˆå¤šï¼Œæ‰€ä»¥æˆ‘ä»¬é€šè¿‡åˆ†æ boost ä¸­å¼‚æ­¥å®šæ—¶å™¨çš„æºç æ¥è¯¦ç»†å±•å¼€ä¸‹ã€‚  
å…ˆç”»ä¸ªå›¾:  
![boost å¼‚æ­¥å®šæ—¶ä»»åŠ¡æµç¨‹](https://raw.githubusercontent.com/vorshen/blog/master/timer/assets/4.png)  
ç„¶åæˆ‘ä»¬ä¾æ¬¡çœ‹ä¸€ä¸‹ã€‚

1.  å°† timer_fd ç»‘å®šåˆ° epoll_fd ä¸Š  
    epoll ä½¿ç”¨ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ (epoll_fd) ç®¡ç†å¤šä¸ªæè¿°ç¬¦ (ä¾‹å¦‚è¿™é‡Œçš„ timer_fd)ï¼Œè¿™æ ·åœ¨ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´çš„ copy åªéœ€ä¸€æ¬¡ã€‚  
    **åˆ‡è®°ï¼šè¿™é‡Œ timer_fd ä¹Ÿéœ€è¦è¿›è¡Œå¤ç”¨ï¼Œå¦‚æœæ¯æ¬¡ä¸€ä¸ªå®šæ—¶ä»»åŠ¡ï¼Œéƒ½ç”¨ä¸€ä¸ªæ–°çš„ timer_fdï¼Œä¼šæœ‰ä¸¥é‡çš„æ€§èƒ½æµªè´¹ã€‚**

    ```javascript
    // epoll_reactor.ipp
    epoll_reactor::epoll_reactor(boost::asio::execution_context& ctx)
    : execution_context_service_base<epoll_reactor>(ctx),
    scheduler_(use_service<scheduler>(ctx)),
    mutex_(BOOST_ASIO_CONCURRENCY_HINT_IS_LOCKING(
    Â Â Â Â Â Â REACTOR_REGISTRATION, scheduler_.concurrency_hint())),
    interrupter_(),
    epoll_fd_(do_epoll_create()), // â—åˆ›å»ºäº† epoll_fd(epoll_create)
    timer_fd_(do_timerfd_create()), // â—åˆ›å»ºäº† timer_fd
    shutdown_(false),
    registered_descriptors_mutex_(mutex_.enabled())
    {
    // Add the interrupter's descriptor to epoll.
    epoll_event ev = { 0, { 0 } };
    ev.events = EPOLLIN | EPOLLERR | EPOLLET;
    ev.data.ptr = &interrupter_;
    epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, interrupter_.read_descriptor(), &ev);
    interrupter_.interrupt();
    Â 
    // Add the timer descriptor to epoll.
    if (timer_fd_ != -1)
    {
    ev.events = EPOLLIN | EPOLLERR;
    ev.data.ptr = &timer_fd_;
    epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, timer_fd_, &ev); // â—å…³è” timer_fd ä¸ epoll_fd
    }
    }
    ```

    æ•´ä½“è¾ƒå¥½ç†è§£ï¼Œå‡ ä¸ªé‡è¦çš„ç‚¹å¢åŠ äº†æ³¨é‡Š
2.  æ·»åŠ ä»»åŠ¡åˆ° timer_queue

    ```javascript
    // timer_queue.hpp
    // Add a new timer to the queue. Returns true if this is the timer that is
    // earliest in the queue, in which case the reactor's event demultiplexing
    // function call may need to be interrupted and restarted.
    bool enqueue_timer(const time_type& time, per_timer_data& timer, wait_op* op)
    {
    // Enqueue the timer object.
    // ç•¥
    Â 
    // Enqueue the individual timer operation.
    timer.op_queue_.push(op);
    Â 
    // Interrupt reactor only if newly added timer is first to expire.
    return timer.heap_index_ == 0 && timer.op_queue_.front() == op;
    }
    // The heap of timers, with the earliest timer at the front.
    std::vector<heap_entry> heap_;
    ```

    enqueue_timer é‡Œé¢å¤§éƒ¨åˆ†ä»£ç æˆ‘çœç•¥æ‰äº†ï¼Œä¹Ÿå°±æ˜¯åœ¨ç»´æŠ¤ä¸€ä¸ªå°æ ¹å †ï¼Œè®©æœ€è¿‘çš„å®šæ—¶ä»»åŠ¡åœ¨å‰é¢ï¼Œè¿™æ ·å¯ä»¥æ–¹ä¾¿ç¬¬ä¸‰æ­¥å¯åŠ¨å’Œæ›´æ–° timerfdã€‚  
    _BTW: è¿™é‡Œå°æ ¹å †å¹¶ä¸æ˜¯åƒæˆ‘ä»¬ä¹‹å‰ demo ç”¨äº† priority_queue æ–¹å¼ï¼Œè€Œæ˜¯æ¯æ¬¡ push_back ä¼šå» swap ä¿®æ”¹ vectorã€‚_
3.  å¯åŠ¨ / æ›´æ–° timerfd  
    ç»“åˆä¸Šä¸€èŠ‚çš„ä»£ç ï¼Œå½“ enqueue_timer è¿”å› true çš„æ—¶å€™ï¼Œå°±ä¼šå»æ›´æ–° / å¯åŠ¨å®šæ—¶å™¨ã€‚

    ```c
    // epoll_reactor.hpp
    bool earliest = queue.enqueue_timer(time, timer, op);
    // ...
    if (earliest)
    update_timeout(); // â—æ›´æ–°å®šæ—¶å™¨
    ///////////////
    // epoll_reactor.ipp
    void epoll_reactor::update_timeout()
    {
    #if defined(BOOST_ASIO_HAS_TIMERFD)
    if (timer_fd_ != -1)
    {
    itimerspec new_timeout;
    itimerspec old_timeout;
    int flags = get_timeout(new_timeout);
    timerfd_settime(timer_fd_, flags, &new_timeout, &old_timeout); // â—è®¾ç½® timerfd
    return;
    }
    #endif // defined(BOOST_ASIO_HAS_TIMERFD)
    interrupt();
    }
    ```

    æ³¨æ„ï¼šå¦‚æœä¸æ”¯æŒ timerfdï¼Œåˆ™ä¼šç›´æ¥è°ƒç”¨ epoll_ctlã€‚
4.  å¯åŠ¨ epoll_wait
5.  æ”¶åˆ° IO äº‹ä»¶ï¼Œä» timer_queue ä¸­åˆ¤æ–­è¿‡æœŸä»»åŠ¡

è¿™ä¸¤æ­¥çš„ä»£ç ä½ç½®å¤ªè¿‡ç›¸è¿‘ï¼Œå°±æ”¾ä¸€èµ·æ¥è¯´äº†ã€‚

```c
// epoll_reactor.hpp
void epoll_reactor::run(long usec, op_queue<operation>& ops)
{
Â Â // This code relies on the fact that the scheduler queues the reactor task
Â Â // behind all descriptor operations generated by this function. This means,
Â Â // that by the time we reach this point, any previously returned descriptor
Â Â // operations have already been dequeued. Therefore it is now safe for us to
Â Â // reuse and return them for the scheduler to queue again.
Â 
Â Â // Calculate timeout. Check the timer queues only if timerfd is not in use.
Â Â int timeout;
Â Â if (usec == 0)
Â Â Â Â timeout = 0;
Â Â else
Â Â {
Â Â Â Â timeout = (usec < 0) ? -1 : ((usec - 1) / 1000 + 1);
Â Â Â Â if (timer_fd_ == -1)
Â Â Â Â {
Â Â Â Â Â Â mutex::scoped_lock lock(mutex_);
Â Â Â Â Â Â timeout = get_timeout(timeout);
Â Â Â Â }
Â Â }
Â 
Â Â // Block on the epoll descriptor.
Â Â epoll_event events[128];
Â Â int num_events = epoll_wait(epoll_fd_, events, 128, timeout); // â—æ ¸å¿ƒ
Â 
Â Â // ...
Â 
#if defined(BOOST_ASIO_HAS_TIMERFD)
Â Â bool check_timers = (timer_fd_ == -1);
#else // defined(BOOST_ASIO_HAS_TIMERFD)
Â Â bool check_timers = true;
#endif // defined(BOOST_ASIO_HAS_TIMERFD)
Â 
Â Â // Dispatch the waiting events.
Â Â for (int i = 0; i < num_events; ++i)
Â Â {
Â Â Â Â void* ptr = events[i].data.ptr;
Â Â Â Â if (ptr == &interrupter_)
Â Â Â Â {
Â Â Â Â Â Â // No need to reset the interrupter since we're leaving the descriptor
Â Â Â Â Â Â // in a ready-to-read state and relying on edge-triggered notifications
Â Â Â Â Â Â // to make it so that we only get woken up when the descriptor's epoll
Â Â Â Â Â Â // registration is updated.
Â 
#if defined(BOOST_ASIO_HAS_TIMERFD)
Â Â Â Â Â Â if (timer_fd_ == -1)
Â Â Â Â Â Â Â Â check_timers = true;
#else // defined(BOOST_ASIO_HAS_TIMERFD)
Â Â Â Â Â Â check_timers = true;
#endif // defined(BOOST_ASIO_HAS_TIMERFD)
Â Â Â Â }
#if defined(BOOST_ASIO_HAS_TIMERFD)
Â Â Â Â else if (ptr == &timer_fd_)
Â Â Â Â {
Â Â Â Â Â Â check_timers = true;
Â Â Â Â }
#endif // defined(BOOST_ASIO_HAS_TIMERFD)
Â Â Â Â else
Â Â Â Â {
Â Â Â Â Â Â // The descriptor operation doesn't count as work in and of itself, so we
Â Â Â Â Â Â // don't call work_started() here. This still allows the scheduler to
Â Â Â Â Â Â // stop if the only remaining operations are descriptor operations.
Â Â Â Â Â Â descriptor_state* descriptor_data = static_cast<descriptor_state*>(ptr);
Â Â Â Â Â Â if (!ops.is_enqueued(descriptor_data))
Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â descriptor_data->set_ready_events(events[i].events);
Â Â Â Â Â Â Â Â ops.push(descriptor_data);
Â Â Â Â Â Â }
Â Â Â Â Â Â else
Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â descriptor_data->add_ready_events(events[i].events);
Â Â Â Â Â Â }
Â Â Â Â }
Â Â }
Â 
Â Â if (check_timers) // â—check_timers ä¸º true æ„å‘³ç€éœ€è¦æ£€æµ‹å®šæ—¶å™¨é˜Ÿåˆ—
Â Â {
Â Â Â Â mutex::scoped_lock common_lock(mutex_);
Â Â Â Â timer_queues_.get_ready_timers(ops); // â—è·å–å·²ç»å®ŒæˆçŠ¶æ€çš„äº‹ä»¶å¹¶æ‰§è¡Œ
Â 
#if defined(BOOST_ASIO_HAS_TIMERFD)
Â Â Â Â if (timer_fd_ != -1)
Â Â Â Â {
Â Â Â Â Â Â itimerspec new_timeout;
Â Â Â Â Â Â itimerspec old_timeout;
Â Â Â Â Â Â int flags = get_timeout(new_timeout);
Â Â Â Â Â Â timerfd_settime(timer_fd_, flags, &new_timeout, &old_timeout); // â—ç»§ç»­è®¾ç½®å®šæ—¶å™¨
Â Â Â Â }
#endif // defined(BOOST_ASIO_HAS_TIMERFD)
Â Â }
}
```

é‡ç‚¹çš„å°±æ˜¯æœ‰â—æ ‡å¿—çš„ä»£ç ã€‚  
timer_queues é‡Œé¢å‘ç°çš„è¿‡æœŸäº‹ä»¶ä¼šæ·»åŠ åˆ° op_queue é‡Œé¢å»ï¼Œå¦‚ä¸‹ï¼š

```c
Â 
// timer_queue.hpp
virtual void get_ready_timers(op_queue<operation>& ops)
{
Â Â if (!heap_.empty())
Â Â {
Â Â Â Â const time_type now = Time_Traits::now();
Â Â Â Â while (!heap_.empty() && !Time_Traits::less_than(now, heap_[0].time_))
Â Â Â Â {
Â Â Â Â Â Â per_timer_data* timer = heap_[0].timer_;
Â Â Â Â Â Â ops.push(timer->op_queue_);
Â Â Â Â Â Â remove_timer(*timer);
Â Â Â Â }
Â Â }
}
```

op_queue ä¼šåœ¨ scheduler.ipp å†…è¿›è¡Œæ‰§è¡Œã€‚

ä»¥ä¸Šå°±æ˜¯ boost ä¸­çš„å¼‚æ­¥å®šæ—¶å™¨æ‰§è¡Œåˆ†è§£ï¼Œæ„Ÿå…´è¶£çš„åŒå­¦ä¹Ÿå¯ä»¥è‡ªå·±ä¸‹æºç æ¥å­¦ä¹ ã€‚  
_BTW: libevent ä¸­å®šæ—¶ä»»åŠ¡åšæ³•ä¸ boost åŸºæœ¬ä¸€è‡´ï¼Œchromium åº•å±‚çš„ message_pump ä¹Ÿæœ‰ä½¿ç”¨ libeventã€‚_

## æ€»ç»“

æˆ‘ä»¬äº†è§£åˆ°éœ€è¦å®ç°ä¸€ä¸ªå®šæ—¶å™¨ / å®šæ—¶ä»»åŠ¡ï¼Œé‡ç‚¹éœ€è¦ä¸¤å—ï¼š

1.  å­˜æ”¾æ‰§è¡Œå›è°ƒçš„åœ°æ–¹  
    å¤§éƒ¨åˆ†é€‰æ‹©æ˜¯å°æ ¹å †çš„æ–¹æ¡ˆï¼Œç®€å•æ–¹ä¾¿ï¼›ä¹Ÿæœ‰æ—¶é—´è½®çš„æ–¹æ¡ˆã€‚
2.  è°ƒç”¨æ“ä½œç³»ç»Ÿæä¾›çš„å®šæ—¶èƒ½åŠ›  
    æˆ‘ä»¬åˆ†æäº†ã€Œä¿¡å·ã€ã€ŒPOSIX Timerã€ã€Œå¤šè·¯å¤ç”¨ã€ï¼Œä¿¡å· passï¼ŒåäºŒè€…ä¸­æ›´æ¨èå¤šè·¯å¤ç”¨ä¸€äº›ã€‚  
    åˆ†æäº† boost asio çš„æºç ï¼Œå­¦ä¹ äº†å¤šè·¯å¤ç”¨èƒ½åŠ›ç”¨åœ¨å®šæ—¶æ–¹é¢çš„è§£å†³åŠæ³•ã€‚

å¦‚æœä½ è¿˜æƒ³äº†è§£çš„æ›´å¤šï¼Œå¯ä»¥å­¦ä¹  libeventã€libcoã€chromium ä¸­å®šæ—¶å™¨æ–¹é¢é‡‡å–çš„æ–¹æ¡ˆã€‚  
æ¬¢è¿ä¸€èµ·è®¨è®ºç ”ç©¶ï½


<!-- {% endraw %} - for jekyll -->