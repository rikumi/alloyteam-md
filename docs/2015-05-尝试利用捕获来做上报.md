---
title: 尝试利用捕获来做上报
date: 2015-05-08
author: TAT.kaelyang
source_link: http://www.alloyteam.com/2015/05/%e5%b0%9d%e8%af%95%e5%88%a9%e7%94%a8%e6%8d%95%e8%8e%b7%e6%9d%a5%e5%81%9a%e4%b8%8a%e6%8a%a5/
---

<!-- {% raw %} - for jekyll -->

* * *

标准浏览器的事件模型是先捕获再冒泡，由于考虑到兼容问题，事件绑定一般都是基于冒泡来做的，那么什么情况下可以考虑利用捕获来做事件绑定呢？

最近在做的课程查找页上报需求的时候，有两个问题要解决：

> 1.  清理之前做的上报
> 2.  重新添加新的上报

如果在原来的基础上直接改当然可以，但是将上报和业务代码耦合显然不是理想的解决方案，由于内嵌的 webview 是 chromium， 不用考虑兼容问题，于是尝试利用捕获来处理。

> 1.  大多数的上报都是点击上报
> 2.  捕获先于冒泡，不用考虑 stopPropagation 的影响

所以可以在最外层，基于捕获来绑定事件：

```html
&lt;span class="keyword">var&lt;/span> getReportKey = &lt;span class="keyword">function&lt;/span>(&lt;span class="variable">$ele&lt;/span>, max) {
    &lt;span class="comment">// 这里需要设置一个 max 值, 避免死循环&lt;/span>
    max = parseInt(max, &lt;span class="number">10&lt;/span>) || &lt;span class="number">5&lt;/span>;
    &lt;span class="keyword">var&lt;/span> key = [];
    &lt;span class="keyword">var&lt;/span> id = &lt;span class="string">''&lt;/span>;
    &lt;span class="keyword">do&lt;/span> {
        id = &lt;span class="variable">$ele&lt;/span>.attr(&lt;span class="string">'id'&lt;/span>);
        &lt;span class="keyword">if&lt;/span> (id) {
            key.push(&lt;span class="string">'#'&lt;/span> + id);
        } &lt;span class="keyword">else&lt;/span> {
            key.push(&lt;span class="variable">$ele&lt;/span>.prop(&lt;span class="string">"tagName"&lt;/span>).toLowerCase());
            &lt;span class="variable">$ele&lt;/span> = &lt;span class="variable">$ele&lt;/span>.&lt;span class="keyword">parent&lt;/span>();
        }
    } &lt;span class="keyword">while&lt;/span> (!id && --max);
    &lt;span class="keyword">return&lt;/span> key.reverse().join(&lt;span class="string">' '&lt;/span>);
};
 
$(&lt;span class="string">'#container'&lt;/span>)[&lt;span class="number">0&lt;/span>].addEventListener(&lt;span class="string">'click'&lt;/span>, &lt;span class="keyword">function&lt;/span>(event) {
    &lt;span class="comment">// 获得鼠标点击的元素&lt;/span>
    &lt;span class="keyword">var&lt;/span> &lt;span class="variable">$target&lt;/span> = $(event.target);
    &lt;span class="comment">// 根据该元素获取上报的 key&lt;/span>
    &lt;span class="keyword">var&lt;/span> reportKey = getReportKey(&lt;span class="variable">$target&lt;/span>);
    &lt;span class="keyword">var&lt;/span> data = &lt;span class="keyword">null&lt;/span>;
    &lt;span class="keyword">switch&lt;/span> (reportKey) {
        &lt;span class="keyword">case&lt;/span> &lt;span class="string">'#container h3 a'&lt;/span>:
            data = {
                action: &lt;span class="string">'title_clk'&lt;/span>
            };
            &lt;span class="keyword">break&lt;/span>;
        &lt;span class="comment">// and so on&lt;/span>
        &lt;span class="keyword">default&lt;/span>:
            &lt;span class="keyword">break&lt;/span>;
    }
    data && todoReport(data);
}, &lt;span class="keyword">true&lt;/span>);
 
```

以上，所有要上报的点都可以在 switch 里完成，同时可以避免和业务逻辑的耦合。

此外，对于页面资源的加载监控等也可以使用捕获来做。


<!-- {% endraw %} - for jekyll -->