---
title: Service Worker 初体验
date: 2016-01-06
author: he, terence
source_link: http://www.alloyteam.com/2016/01/9274/
---

<!-- {% raw %} - for jekyll -->

在 2014 年，W3C 公布了 service worker 的草案，service worker 提供了很多新的能力，使得 web app 拥有与 native app 相同的离线体验、消息推送体验。  
service worker 是一段脚本，与 web worker 一样，也是在后台运行。作为一个独立的线程，运行环境与普通脚本不同，所以不能直接参与 web 交互行为。native app 可以做到离线使用、消息推送、后台自动更新，service worker 的出现是正是为了使得 web app 也可以具有类似的能力。

service worker 可以：

1.  后台消息传递
2.  网络代理，转发请求，伪造响应
3.  离线缓存
4.  消息推送
5.   ... ...

本文以资源缓存为例，说明一下 service worker 是如何工作的。

生命周期  

* * *

先来看一下一个 service worker 的运行周期

![](http://segmentfault.com/img/bVrKGT)  
上图是 service worker 生命周期，出处 <http://www.html5rocks.com/en/tutorials/service-worker/introduction/>

图中可以看到，一个 service worker 要经历以下过程：

    1\.   安装

    2\.   激活，激活成功之后，打开 chrome://inspect/#service-workers 可以查看到当前运行的 service worker

        ![](http://segmentfault.com/img/bVrKH9)

    3\. 监听 fetch 和 message 事件，下面两种事件会进行简要描述

    4\. 销毁，是否销毁由浏览器决定，如果一个 service worker 长期不使用或者机器内存有限，则可能会销毁这个 worker

fetch 事件  

* * *

在页面发起 http 请求时，service worker 可以通过 fetch 事件拦截请求，并且给出自己的响应。  
w3c 提供了一个新的 fetch api，用于取代 XMLHttpRequest，与 XMLHttpRequest 最大不同有两点：

     1\. fetch () 方法返回的是 Promise 对象，通过 then 方法进行连续调用，减少嵌套。ES6 的 Promise 在成为标准之后，会越来越方便开发人员。

      2.  提供了 Request、Response 对象，如果做过后端开发，对 Request、Response 应该比较熟悉。前端要发起请求可以通过 url 发起，也可以使用 Request 对象发起，而且 Request 可以复用。但是 Response 用在哪里呢？在 service worker 出现之前，前端确实不会自己给自己发消息，但是有了 service worker，就可以在拦截请求之后根据需要发回自己的响应，对页面而言，这个普通的请求结果并没有区别，这是 Response 的一处应用。

下面是在 <http://www.sitepoint.com/introduction-to-the-fetch-api/>中，作者利用 fetch api 通过 fliker 的公开 api 获取图片的例子，注释中详细解释了每一步的作用：

```javascript
/* 由于是get请求，直接把参数作为query string传递了 */
var URL =
    "https://api.flickr.com/services/rest/?method=flickr.photos.search&api_key=your_api_key&format=json&nojsoncallback=1&tags=penguins";
function fetchDemo() {
    // fetch(url, option)支持两个参数，option中可以设置header、body、method信息
    fetch(URL)
        .then(function (response) {
            // 通过promise 对象获得相应内容，并且将响应内容按照json格式转成对象，json()方法调用之后返回的依然是promise对象
            // 也可以把内容转化成arraybuffer、blob对象
            return response.json();
        })
        .then(function (json) {
            // 渲染页面
            insertPhotos(json);
        });
}
fetchDemo();
```

fetch api 与 XMLHttpRequest 相比，更加简洁，并且提供的功能更全面，资源获取方式比 ajax 更优雅。兼容性方面：chrome 42 开始支持，对于旧浏览器，可以通过官方维护的 polyfill 支持。

message 事件  

* * *

页面和 serviceWorker 之间可以通过 posetMessage () 方法发送消息，发送的消息可以通过 message 事件接收到。

这是一个双向的过程，页面可以发消息给 service worker，service worker 也可以发送消息给页面，由于这个特性，可以将 service worker 作为中间纽带，使得一个域名或者子域名下的多个页面可以自由通信。

这里是一个小的页面之间通信 demo<https://nzv3tos3n.qnssl.com/message/msg-demo.html>

利用 service workder 缓存文件  

* * *

下面介绍一个利用 service worker 缓存离线文件的例子  
准备 index.js，用于注册 service-worker

```javascript
if (navigator.serviceWorker) {
    navigator.serviceWorker.register('service-worker.js').then(function(registration) {
        console.log('service worker 注册成功');
    }).catch(function (err) {
        console.log('servcie worker 
```


<!-- {% endraw %} - for jekyll -->